<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>debugging on Nick Desaulniers</title><link>https://nickdesaulniers.github.io/categories/debugging/</link><description>Recent content in debugging on Nick Desaulniers</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 18 Jan 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://nickdesaulniers.github.io/categories/debugging/index.xml" rel="self" type="application/rss+xml"/><item><title>Finding Compiler Bugs With C-Reduce</title><link>https://nickdesaulniers.github.io/blog/2019/01/18/finding-compiler-bugs-with-c-reduce/</link><pubDate>Fri, 18 Jan 2019 00:00:00 +0000</pubDate><guid>https://nickdesaulniers.github.io/blog/2019/01/18/finding-compiler-bugs-with-c-reduce/</guid><description>Support for a long awaited GNU C extension, asm goto, is in the midst of landing in Clang and LLVM. We want to make sure that we release a high quality implementation, so it&amp;rsquo;s important to test the new patches on real code and not just small test cases. When we hit compiler bugs in large source files, it can be tricky to find exactly what part of potentially large translation units are problematic.</description></item><item><title>Booting a Custom Linux Kernel in QEMU and Debugging It With GDB</title><link>https://nickdesaulniers.github.io/blog/2018/10/24/booting-a-custom-linux-kernel-in-qemu-and-debugging-it-with-gdb/</link><pubDate>Wed, 24 Oct 2018 00:00:00 +0000</pubDate><guid>https://nickdesaulniers.github.io/blog/2018/10/24/booting-a-custom-linux-kernel-in-qemu-and-debugging-it-with-gdb/</guid><description>Typically, when we modify a program, we’d like to run it to verify our changes. Before booting a compiled Linux kernel image on actual hardware, it can save us time and potential headache to do a quick boot in a virtual machine like QEMU as a sanity check. If your kernel boots in QEMU, it’s not a guarantee it will boot on metal, but it is a quick assurance that the kernel image is not completely busted.</description></item><item><title>Object Files and Symbols</title><link>https://nickdesaulniers.github.io/blog/2016/08/13/object-files-and-symbols/</link><pubDate>Sat, 13 Aug 2016 00:00:00 +0000</pubDate><guid>https://nickdesaulniers.github.io/blog/2016/08/13/object-files-and-symbols/</guid><description>What was supposed to be one blog post about memory segmentation turned into what will be a series of posts. As the first in the series, we cover the extreme basics of object files and symbols. In follow up posts, I plan to talk about static libraries, dynamic libraries, dynamic linkage, memory segments, and finally memory usage accounting. I also cover command line tools for working with these notions, both in Linux and OSX.</description></item></channel></rss>