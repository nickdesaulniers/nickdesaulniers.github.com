<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on Nick Desaulniers</title>
    <link>https://nickdesaulniers.github.io/categories/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on Nick Desaulniers</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 12 May 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://nickdesaulniers.github.io/categories/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>f() vs f(void) in C vs C&#43;&#43;</title>
      <link>https://nickdesaulniers.github.io/blog/2019/05/12/f-vs-f-void-in-c-vs-c-plus-plus/</link>
      <pubDate>Sun, 12 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://nickdesaulniers.github.io/blog/2019/05/12/f-vs-f-void-in-c-vs-c-plus-plus/</guid>
      <description>TL;DR
Prefer f(void) in C to potentially save a 2B instruction per function call when targeting x86_64 as a micro-optimization. -Wstrict-prototypes can help. Doesn’t matter for C++.
The Problem While messing around with some C code in godbolt Compiler Explorer, I kept noticing a particular funny case. It seemed with my small test cases that sometimes function calls would zero out the return register before calling a function that took no arguments, but other times not.</description>
    </item>
    
    <item>
      <title>Finding Compiler Bugs With C-Reduce</title>
      <link>https://nickdesaulniers.github.io/blog/2019/01/18/finding-compiler-bugs-with-c-reduce/</link>
      <pubDate>Fri, 18 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://nickdesaulniers.github.io/blog/2019/01/18/finding-compiler-bugs-with-c-reduce/</guid>
      <description>Support for a long awaited GNU C extension, asm goto, is in the midst of landing in Clang and LLVM. We want to make sure that we release a high quality implementation, so it&amp;rsquo;s important to test the new patches on real code and not just small test cases. When we hit compiler bugs in large source files, it can be tricky to find exactly what part of potentially large translation units are problematic.</description>
    </item>
    
    <item>
      <title>Static and Dynamic Libraries</title>
      <link>https://nickdesaulniers.github.io/blog/2016/11/20/static-and-dynamic-libraries/</link>
      <pubDate>Sun, 20 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://nickdesaulniers.github.io/blog/2016/11/20/static-and-dynamic-libraries/</guid>
      <description>This is the second post in a series on memory segmentation. It covers working with static and dynamic libraries in Linux and OSX. Make sure to check out the first on object files and symbols.
Let’s say we wanted to reuse some of the code from our previous project in our next one. We could continue to copy around object files, but let’s say we have a bunch and it’s hard to keep track of all of them.</description>
    </item>
    
    <item>
      <title>Object Files and Symbols</title>
      <link>https://nickdesaulniers.github.io/blog/2016/08/13/object-files-and-symbols/</link>
      <pubDate>Sat, 13 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://nickdesaulniers.github.io/blog/2016/08/13/object-files-and-symbols/</guid>
      <description>What was supposed to be one blog post about memory segmentation turned into what will be a series of posts. As the first in the series, we cover the extreme basics of object files and symbols. In follow up posts, I plan to talk about static libraries, dynamic libraries, dynamic linkage, memory segments, and finally memory usage accounting. I also cover command line tools for working with these notions, both in Linux and OSX.</description>
    </item>
    
    <item>
      <title>Cross Compiling C/C&#43;&#43; for Android</title>
      <link>https://nickdesaulniers.github.io/blog/2016/07/01/android-cli/</link>
      <pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://nickdesaulniers.github.io/blog/2016/07/01/android-cli/</guid>
      <description>Let’s say you want to build a hello world command line application in C or C++ and run it on your Android phone. How would you go about it? It’s not super practical; apps visible and distributable to end users must use the framework (AFAIK), but for folks looking to get into developing on ARM it’s likely they have an ARM device in their pocket.
This post is for folks who typically invoke their compiler from the command line, either explicitly, from build scripts, or other forms of automation.</description>
    </item>
    
    <item>
      <title>Additional C/C&#43;&#43; Tooling</title>
      <link>https://nickdesaulniers.github.io/blog/2015/07/23/additional-c-slash-c-plus-plus-tooling/</link>
      <pubDate>Thu, 23 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://nickdesaulniers.github.io/blog/2015/07/23/additional-c-slash-c-plus-plus-tooling/</guid>
      <description>21st Century C by Ben Klemens was a great read. It had a section with an intro to autotools, git, and gdb. There are a few other useful tools that came to mind that I&amp;rsquo;ve used when working with C and C++ codebases. These tools are a great way to start contributing to Open Source C &amp;amp; C++ codebases; running these tools on the code or adding them to the codebases.</description>
    </item>
    
    <item>
      <title>Rust: Pattern Matching and the Option Type</title>
      <link>https://nickdesaulniers.github.io/blog/2013/05/07/rust-pattern-matching-and-the-option-type/</link>
      <pubDate>Tue, 07 May 2013 00:00:00 +0000</pubDate>
      
      <guid>https://nickdesaulniers.github.io/blog/2013/05/07/rust-pattern-matching-and-the-option-type/</guid>
      <description>The other day I was thinking about the function for performing dynamic memory allocation in the C standard library, malloc. From the manual pages, If successful, the malloc() function returns a pointer to allocated memory. If there is an error, it returns a NULL pointer and sets errno to ENOMEM. One of the most common errors when using malloc is not checking for allocation failure. The allocation is not guaranteed to succeed and trying to use a NULL reference can lead to program crashes.</description>
    </item>
    
  </channel>
</rss>
