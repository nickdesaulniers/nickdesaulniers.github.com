<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=/css/fonts.css rel=stylesheet type=text/css><title>Interpreter Compiler JIT</title><link rel=stylesheet href=/css/hugo-octopress.css><link rel=stylesheet href=https://nickdesaulniers.github.io/css/custom.css><link rel=stylesheet href=/css/fork-awesome.min.css><link href=https://nickdesaulniers.github.io/favicon.ico rel=icon><meta name=description content><meta name=keywords content><meta name=author content="Nick Desaulniers"><meta name=generator content="Hugo 0.109.0"></head><body><header role=banner><hgroup><h1><a href=https://nickdesaulniers.github.io/>Nick Desaulniers</a></h1><h2>The enemy's gate is down</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value"><option value>Navigate…</option><option value=https://nickdesaulniers.github.io/about/>» About</option><option value=https://nickdesaulniers.github.io/blog/archives/>» Archives</option><option value=https://nickdesaulniers.github.io/>» Blog</option><option value=https://nickdesaulniers.github.io/publications/>» Publications</option><option value=https://nickdesaulniers.github.io/talks/>» Talks</option></select></fieldset><ul class=main-navigation><li><a href=https://nickdesaulniers.github.io/about/ title=About rel="noopener noreferrer">About</a></li><li><a href=https://nickdesaulniers.github.io/blog/archives/ title=Archives rel="noopener noreferrer">Archives</a></li><li><a href=https://nickdesaulniers.github.io/ title=Blog>Blog</a></li><li><a href=https://nickdesaulniers.github.io/publications/ title=Publications rel="noopener noreferrer">Publications</a></li><li><a href=https://nickdesaulniers.github.io/talks/ title=Talks rel="noopener noreferrer">Talks</a></li></ul><ul class=subscription><a href=https://nickdesaulniers.github.io/index.xml target=_blank type=application/rss+xml title=RSS rel="noopener noreferrer"><i class="fa fa-rss-square fa-lg"></i></a></ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer"><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:https://nickdesaulniers.github.io/></fieldset></form></nav><div id=main><div id=content><div><article class=hentry role=article><header><p class=meta>May 25, 2015
- 21 minute read
- <a href=https://nickdesaulniers.github.io/blog/2015/05/25/interpreter-compiler-jit/#disqus_thread>Comments</a>
- <a class=label href=https://nickdesaulniers.github.io/categories/interpreter/>interpreter </a><a class=label href=https://nickdesaulniers.github.io/categories/compiler/>compiler </a><a class=label href=https://nickdesaulniers.github.io/categories/just-in-time/>just in time </a><a class=label href=https://nickdesaulniers.github.io/categories/jit/>JIT </a><a class=label href=https://nickdesaulniers.github.io/categories/brainfuck/>Brainfuck </a><a class=label href=https://nickdesaulniers.github.io/categories/c/>C</a></p><h1 class=entry-title>Interpreter Compiler JIT</h1></header><div class=entry-content><p>Interpreters and compilers are interesting programs, themselves used to run or
translate other programs, respectively. Those other programs that might be
interpreted might be languages like JavaScript, Ruby, Python, PHP, and Perl. The
other programs that might be compiled are C, C++, and to some extent Java and
C#.</p><p>Taking the time to do translation to native machine code ahead of
time can result in better performance at runtime, but an interpreter can get to work right away without spending any time translating. There happens to be a sweet spot
somewhere in between interpretation and compilation that combines the best of
both worlds. Such a technique
is called Just In Time (JIT) compiling. While interpreting, compiling, and JIT&rsquo;ing code might sound radically different, they&rsquo;re actually strikingly similar. In
this post, I hope to show how similar by comparing the code for an interpreter,
a compiler, and a JIT compiler for the language Brainfuck in around 100 lines
of C code each.</p><p>All of the code in the post is up on
<a href=https://github.com/nickdesaulniers/bf_interpreter_jit_compiler target=_blank rel=noopener>GitHub</a>.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe src=https://www.youtube.com/embed/_C5AHaS1mOA style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="YouTube Video"></iframe></div><p>Brainfuck is an interesting, if hard to read, language. It only has eight
operations it can perform <code>> &lt; + - . , [ ]</code>, yet is Turing complete. There&rsquo;s nothing really to
lex; each character is a token, and if the token is not one of the eight
operators, it&rsquo;s ignored. There&rsquo;s also not much of a grammar to parse; the
forward jumping and backwards jumping operators should be matched for well
formed input, but that&rsquo;s about it. In this post, we&rsquo;ll skip over validating
input assuming well formed input so we can focus on the interpretation/code
generation. You can read more about it on the
<a href=http://en.wikipedia.org/wiki/Brainfuck target=_blank rel=noopener>Wikipedia page</a>,
which we&rsquo;ll be using as a reference throughout.</p><p>A Brainfuck program operates on a 30,000 element byte array initialized to all
zeros. It starts off with an instruction pointer, that initially points to the
first element in the data array or &ldquo;tape.&rdquo; In C code for an interpreter that
might look like:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#586e75>// Initialize the tape with 30,000 zeroes.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>char</span> tape [<span style=color:#2aa198>30000</span>] <span style=color:#719e07>=</span> { <span style=color:#2aa198>0</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>// Set the pointer to point at the left most cell of the tape.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>char</span><span style=color:#719e07>*</span> ptr <span style=color:#719e07>=</span> tape;
</span></span></code></pre></div><p>Then, since we&rsquo;re performing an operation for each character in the Brainfuck
source, we can have a for loop over every character with a nested switch
statement containing case statements for each operator.</p><p>The first two operators, <code>></code> and <code>&lt;</code> increment and decrement the data pointer.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;&gt;&#39;</span><span style=color:#719e07>:</span> <span style=color:#719e07>++</span>ptr; <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;&lt;&#39;</span><span style=color:#719e07>:</span> <span style=color:#719e07>--</span>ptr; <span style=color:#719e07>break</span>;
</span></span></code></pre></div><p>One thing that could be bad is that because the interpreter is written in C and
we&rsquo;re representing the tape as an array but we&rsquo;re not validating our inputs,
there&rsquo;s potential for stack buffer overrun since we&rsquo;re not performing bounds
checks. Again, punting and assuming well formed input to keep the code and the
point more precise.</p><p>Next up are the <code>+</code> and <code>-</code> operators, used for incrementing and decrementing
the cell pointed to by the data pointer by one.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;+&#39;</span><span style=color:#719e07>:</span> <span style=color:#719e07>++</span>(<span style=color:#719e07>*</span>ptr); <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;-&#39;</span><span style=color:#719e07>:</span> <span style=color:#719e07>--</span>(<span style=color:#719e07>*</span>ptr); <span style=color:#719e07>break</span>;
</span></span></code></pre></div><p>The operators <code>.</code> and <code>,</code> provide Brainfuck&rsquo;s only means of input or output, by
writing the value pointed to by the instruction pointer to stdout as an ASCII
value, or reading one byte from stdin as an ASCII value and writing it to the
cell pointed to by the instruction pointer.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;.&#39;</span><span style=color:#719e07>:</span> <span style=color:#268bd2>putchar</span>(<span style=color:#719e07>*</span>ptr); <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;,&#39;</span><span style=color:#719e07>:</span> <span style=color:#719e07>*</span>ptr <span style=color:#719e07>=</span> <span style=color:#268bd2>getchar</span>(); <span style=color:#719e07>break</span>;
</span></span></code></pre></div><p>Finally, our looping constructs, <code>[</code> and <code>]</code>. From the definition on Wikipedia
for <code>[</code>: <code>if the byte at the data pointer is zero, then instead of moving the instruction pointer forward to the next command, jump it forward to the command after the matching ] command</code> and for <code>]</code>: <code>if the byte at the data pointer is nonzero, then instead of moving the instruction pointer forward to the next command, jump it back to the command after the matching [ command.</code></p><p>I interpret that as:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;[&#39;</span><span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>  <span style=color:#719e07>if</span> (<span style=color:#719e07>!</span>(<span style=color:#719e07>*</span>ptr)) {
</span></span><span style=display:flex><span>    <span style=color:#dc322f>int</span> loop <span style=color:#719e07>=</span> <span style=color:#2aa198>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#719e07>while</span> (loop <span style=color:#719e07>&gt;</span> <span style=color:#2aa198>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>char</span> current_char <span style=color:#719e07>=</span> input[<span style=color:#719e07>++</span>i];
</span></span><span style=display:flex><span>      <span style=color:#719e07>if</span> (current_char <span style=color:#719e07>==</span> <span style=color:#2aa198>&#39;]&#39;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>--</span>loop;
</span></span><span style=display:flex><span>      } <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> (current_char <span style=color:#719e07>==</span> <span style=color:#2aa198>&#39;[&#39;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>++</span>loop;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;]&#39;</span><span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>  <span style=color:#719e07>if</span> (<span style=color:#719e07>*</span>ptr) {
</span></span><span style=display:flex><span>    <span style=color:#dc322f>int</span> loop <span style=color:#719e07>=</span> <span style=color:#2aa198>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#719e07>while</span> (loop <span style=color:#719e07>&gt;</span> <span style=color:#2aa198>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>char</span> current_char <span style=color:#719e07>=</span> input[<span style=color:#719e07>--</span>i];
</span></span><span style=display:flex><span>      <span style=color:#719e07>if</span> (current_char <span style=color:#719e07>==</span> <span style=color:#2aa198>&#39;[&#39;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>--</span>loop;
</span></span><span style=display:flex><span>      } <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> (current_char <span style=color:#719e07>==</span> <span style=color:#2aa198>&#39;]&#39;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>++</span>loop;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#719e07>break</span>;
</span></span></code></pre></div><p>Where the variable <code>loop</code> keeps track of open brackets for which we&rsquo;ve not seen
a matching close bracket, aka our nested depth.</p><p>So
<a href=https://github.com/nickdesaulniers/bf_interpreter_jit_compiler/blob/master/interpreter.c target=_blank rel=noopener>we can see the interpreter is quite basic</a>, in around 50 SLOC were able to
read a byte, and immediately perform an action based on the operator. How we
perform that operation might not be the fastest though.</p><p>How about if we want to compile the Brainfuck source code to native machine
code? Well, we need to know a little bit about our host machine&rsquo;s Instruction
Set Architecture (ISA) and Application Binary Interface (ABI). The rest of the
code in this post will not be as portable as the above C code, since it assumes
an x86-64 ISA and UNIX ABI. Now would be a good time to
<a href=/blog/2014/04/18/lets-write-some-x86-64/>take a detour and learn more about writing assembly for x86-64</a>. The interpreter is even portable enough to
<a href=https://github.com/nickdesaulniers/bf_interpreter_jit_compiler#emscripten target=_blank rel=noopener>build with Emscripten and run in a browser</a>!</p><p>For our compiler, we&rsquo;ll iterate over every character in the source file again,
switching on the recognized operator. This time, instead of performing an
action right away, we&rsquo;ll print assembly instructions to stdout. Doing so
requires running the compiler on an input file, redirecting stdout to a file,
then running the system assembler and linker on that file. We&rsquo;ll stick with
just compiling and not assembling (though it&rsquo;s not too difficult), and linking
(for now).</p><p>First, we need to print a prologue for our compiled code:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>const</span> <span style=color:#dc322f>char</span><span style=color:#719e07>*</span> <span style=color:#719e07>const</span> prologue <span style=color:#719e07>=</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>&#34;.text</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>&#34;.globl _main</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>&#34;_main:</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>&#34;  pushq %rbp</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>&#34;  movq %rsp, %rbp</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>&#34;  pushq %r12</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>        <span style=color:#586e75>// store callee saved register
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#2aa198>&#34;  subq $30008, %rsp</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span> <span style=color:#586e75>// allocate 30,008 B on stack, and realign
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#2aa198>&#34;  leaq (%rsp), %rdi</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span> <span style=color:#586e75>// address of beginning of tape
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#2aa198>&#34;  movl $0, %esi</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>     <span style=color:#586e75>// fill with 0&#39;s
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#2aa198>&#34;  movq $30000, %rdx</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span> <span style=color:#586e75>// length 30,000 B
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#2aa198>&#34;  call _memset</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>      <span style=color:#586e75>// memset
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#2aa198>&#34;  movq %rsp, %r12&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#268bd2>puts</span>(prologue);
</span></span></code></pre></div><p>During the linking phase, we&rsquo;ll make sure to link in libc so we can call
memset. What we&rsquo;re doing is backing up callee saved registers we&rsquo;ll be using,
stack allocating the tape, realigning the stack (
<a href=/blog/2014/04/18/lets-write-some-x86-64/>x86-64 ABI point #1</a>), copying
the address of the only item on the stack into a register for our first
argument, setting the second argument to the constant <code>0</code>, the third arg to
<code>30000</code>, then calling memset. Finally, we use the callee saved register %r12
as our instruction pointer, which is the address into a value on the stack.</p><p>We
can expect the call to memset to result in a segfault if simply subtract just
30000B, and not realign for the 2 registers (64 b each, 8 B each) we pushed on
the stack. The first pushed register aligns the stack on a 16 B boundary, the
second misaligns it; that&rsquo;s why we allocate an additional 8 B on the stack
(
<a href=/blog/2014/04/18/lets-write-some-x86-64/>x86-64 ABI point #1</a>). The stack is mis-aligned upon function entry in x86-64.
30000 is a multiple of 16.</p><p><img src=/images/compiler_stack_alignment.png alt="compiler stack alignment"></p><p>Moving the instruction pointer (<code>></code>, <code>&lt;</code>) and modifying the pointed to value
(<code>+</code>, <code>-</code>) are straight-forward:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;&gt;&#39;</span><span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>  <span style=color:#268bd2>puts</span>(<span style=color:#2aa198>&#34;  inc %r12&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;&lt;&#39;</span><span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>  <span style=color:#268bd2>puts</span>(<span style=color:#2aa198>&#34;  dec %r12&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;+&#39;</span><span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>  <span style=color:#268bd2>puts</span>(<span style=color:#2aa198>&#34;  incb (%r12)&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;-&#39;</span><span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>  <span style=color:#268bd2>puts</span>(<span style=color:#2aa198>&#34;  decb (%r12)&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#719e07>break</span>;
</span></span></code></pre></div><p>For output, <code>.</code>, we need to copy the pointed to byte into the register for the
first argument to putchar. We
explicitly zero out the register before calling putchar, since it takes an int
(32 b), but we&rsquo;re only copying a char (8 b) (Look up C&rsquo;s type promotion rules for more info). x86-64 has an instruction that does both, movzXX, Where the first X is the source size (b, w) and the second is the destination size (w, l, q). Thus movzbl moves a <strong>b</strong>yte (8 b) into a doub<strong>l</strong>e word (32 b). %rdi and %edi are the same register, but %rdi is the full
64 b register, while %edi is the lowest (or least significant) 32 b.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;.&#39;</span><span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>  <span style=color:#586e75>// move byte to double word and zero upper bits since putchar takes an
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#586e75>// int.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#268bd2>puts</span>(<span style=color:#2aa198>&#34;  movzbl (%r12), %edi&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#268bd2>puts</span>(<span style=color:#2aa198>&#34;  call _putchar&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#719e07>break</span>;
</span></span></code></pre></div><p>Input (<code>,</code>) is easy; call getchar, move the resulting lowest byte into the cell
pointed to by the instruction pointer. %al is the lowest 8 b of the 64 b %rax register.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;,&#39;</span><span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>  <span style=color:#268bd2>puts</span>(<span style=color:#2aa198>&#34;  call _getchar&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#268bd2>puts</span>(<span style=color:#2aa198>&#34;  movb %al, (%r12)&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#719e07>break</span>;    
</span></span></code></pre></div><p>As usual, the looping constructs (<code>[</code> & <code>]</code>) are much more work. We have to
match up jumps to matching labels, but for an assembly program, labels must be
unique. One way we can solve for this is whenever we encounter an opening
brace, push a monotonically increasing number that represents the numbers of
opening brackets we&rsquo;ve seen so far onto a stack like data structure. Then, we
do our comparison and jump to what will be the label that should be produced by
the matching close label. Next, we insert our starting label, and finally
increment the number of brackets seen.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;[&#39;</span><span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>  <span style=color:#268bd2>stack_push</span>(<span style=color:#719e07>&amp;</span>stack, num_brackets);
</span></span><span style=display:flex><span>  <span style=color:#268bd2>puts</span>(<span style=color:#2aa198>&#34;  cmpb $0, (%r12)&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#268bd2>printf</span>(<span style=color:#2aa198>&#34;  je bracket_%d_end</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, num_brackets);
</span></span><span style=display:flex><span>  <span style=color:#268bd2>printf</span>(<span style=color:#2aa198>&#34;bracket_%d_start:</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, num_brackets<span style=color:#719e07>++</span>);
</span></span><span style=display:flex><span>  <span style=color:#719e07>break</span>;
</span></span></code></pre></div><p>For close brackets, we pop the number of brackets seen (or rather, number of
pending open brackets which we have yet to see a matching close bracket) off of
the stack, do our comparison, jump to the matching start label, and finally
place our end label.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;]&#39;</span><span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>  <span style=color:#268bd2>stack_pop</span>(<span style=color:#719e07>&amp;</span>stack, <span style=color:#719e07>&amp;</span>matching_bracket);
</span></span><span style=display:flex><span>  <span style=color:#268bd2>puts</span>(<span style=color:#2aa198>&#34;  cmpb $0, (%r12)&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#268bd2>printf</span>(<span style=color:#2aa198>&#34;  jne bracket_%d_start</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, matching_bracket);
</span></span><span style=display:flex><span>  <span style=color:#268bd2>printf</span>(<span style=color:#2aa198>&#34;bracket_%d_end:</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>, matching_bracket);
</span></span><span style=display:flex><span>  <span style=color:#719e07>break</span>;
</span></span></code></pre></div><p>So for sequential loops (<code>[][]</code>) we can expect the relevant assembly to look
like:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gas data-lang=gas><span style=display:flex><span>  <span style=color:#268bd2>cmpb</span> <span style=color:#cb4b16>$0</span>, (<span style=color:#268bd2>%r12</span>)
</span></span><span style=display:flex><span>  <span style=color:#268bd2>je</span> <span style=color:#cb4b16>bracket_0_end</span>
</span></span><span style=display:flex><span>bracket_0_start:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#268bd2>cmpb</span> <span style=color:#cb4b16>$0</span>, (<span style=color:#268bd2>%r12</span>)
</span></span><span style=display:flex><span>  <span style=color:#268bd2>jne</span> <span style=color:#cb4b16>bracket_0_start</span>
</span></span><span style=display:flex><span>bracket_0_end:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#268bd2>cmpb</span> <span style=color:#cb4b16>$0</span>, (<span style=color:#268bd2>%r12</span>)
</span></span><span style=display:flex><span>  <span style=color:#268bd2>je</span> <span style=color:#cb4b16>bracket_1_end</span>
</span></span><span style=display:flex><span>bracket_1_start:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#268bd2>cmpb</span> <span style=color:#cb4b16>$0</span>, (<span style=color:#268bd2>%r12</span>)
</span></span><span style=display:flex><span>  <span style=color:#268bd2>jne</span> <span style=color:#cb4b16>bracket_1_start</span>
</span></span><span style=display:flex><span>bracket_1_end:
</span></span></code></pre></div><p>and for nested loops (<code>[[]]</code>), we can expect assembly like the following (note
the difference in the order of numbered start and end labels):</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gas data-lang=gas><span style=display:flex><span>  <span style=color:#268bd2>cmpb</span> <span style=color:#cb4b16>$0</span>, (<span style=color:#268bd2>%r12</span>)
</span></span><span style=display:flex><span>  <span style=color:#268bd2>je</span> <span style=color:#cb4b16>bracket_0_end</span>
</span></span><span style=display:flex><span>bracket_0_start:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#268bd2>cmpb</span> <span style=color:#cb4b16>$0</span>, (<span style=color:#268bd2>%r12</span>)
</span></span><span style=display:flex><span>  <span style=color:#268bd2>je</span> <span style=color:#cb4b16>bracket_1_end</span>
</span></span><span style=display:flex><span>bracket_1_start:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#268bd2>cmpb</span> <span style=color:#cb4b16>$0</span>, (<span style=color:#268bd2>%r12</span>)
</span></span><span style=display:flex><span>  <span style=color:#268bd2>jne</span> <span style=color:#cb4b16>bracket_1_start</span>
</span></span><span style=display:flex><span>bracket_1_end:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#268bd2>cmpb</span> <span style=color:#cb4b16>$0</span>, (<span style=color:#268bd2>%r12</span>)
</span></span><span style=display:flex><span>  <span style=color:#268bd2>jne</span> <span style=color:#cb4b16>bracket_0_start</span>
</span></span><span style=display:flex><span>bracket_0_end:
</span></span></code></pre></div><p>Finally, we need an epilogue to clean up the stack and callee saved registers
after ourselves.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>const</span> <span style=color:#dc322f>char</span><span style=color:#719e07>*</span> <span style=color:#719e07>const</span> epilogue <span style=color:#719e07>=</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>&#34;  addq $30008, %rsp</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span> <span style=color:#586e75>// clean up tape from stack.
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#2aa198>&#34;  popq %r12</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span> <span style=color:#586e75>// restore callee saved register
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#2aa198>&#34;  popq %rbp</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#2aa198>&#34;  ret</span><span style=color:#cb4b16>\n</span><span style=color:#2aa198>&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#268bd2>puts</span>(epilogue);
</span></span></code></pre></div><p>The compiler is a pain when modifying and running a Brainfuck
program; it takes a couple extra commands to compile the Brainfuck program to
assembly, assemble the assembly into an object file, link it into an
executable, and run it whereas with the interpreter we can just run it. The
trade off is that the compiled version is quite a bit faster. How much faster?
Let&rsquo;s save that for later.</p><p>Wouldn&rsquo;t it be nice if there was a translation & execution technique that
didn&rsquo;t force us to compile our code every time we changed it and wanted to run
it, but also performed closer to that of compiled code? That&rsquo;s where a JIT
compiler comes in!</p><p>For the basics of JITing code, make sure you read
<a href=/blog/2013/04/03/basic-jit/>my previous article on the basics of JITing code in C</a>. We&rsquo;re going to follow the same technique of
creating executable memory, copying bytes into that memory, casting it to a
function pointer, then calling it. Just like the interpreter and the compiler,
we&rsquo;re going to do a unique action for each recognized token. What&rsquo;s different is
that for each operator, we&rsquo;re going to push opcodes into a dynamic array, that
way it can grow based on our sequential reading of input and will simplify our calculation of relative offsets for branching operations.</p><p>The other special thing we&rsquo;re going to do it that we&rsquo;re going to pass
the address of our libc functions (memset, putchar, and getchar) into our
JIT&rsquo;ed function at runtime. This avoids those kooky stub functions you might
see in a disassembled executable. That means we&rsquo;ll be invoking our JIT&rsquo;ed
function like:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>typedef</span> <span style=color:#dc322f>void</span><span style=color:#719e07>*</span> <span style=color:#268bd2>fn_memset</span> (<span style=color:#dc322f>void</span><span style=color:#719e07>*</span>, <span style=color:#dc322f>int</span>, <span style=color:#dc322f>size_t</span>);
</span></span><span style=display:flex><span><span style=color:#719e07>typedef</span> <span style=color:#dc322f>int</span> <span style=color:#268bd2>fn_putchar</span> (<span style=color:#dc322f>int</span>);
</span></span><span style=display:flex><span><span style=color:#719e07>typedef</span> <span style=color:#dc322f>int</span> <span style=color:#268bd2>fn_getchar</span> ();
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> (<span style=color:#719e07>*</span>jitted_func) (fn_memset, fn_putchar, fn_getchar) <span style=color:#719e07>=</span> mem;
</span></span><span style=display:flex><span><span style=color:#268bd2>jitted_func</span>(memset, putchar, getchar);
</span></span></code></pre></div><p>Where mem is our mmap&rsquo;ed executable memory with our opcodes copied into it, and
the typedef&rsquo;s are for the respective function signatures for our function
pointers we&rsquo;ll be passing to our JIT&rsquo;ed code. We&rsquo;re kind of getting ahead of
ourselves, but knowing how we will invoke the dynamically created executable
code will give us an idea of how the code itself will work.</p><p>The prologue is quite a bit involved, so we&rsquo;ll take it step at a time. First,
we have the usual prologue:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#dc322f>char</span> prologue [] <span style=color:#719e07>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#2aa198>0x55</span>, <span style=color:#586e75>// push rbp
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#2aa198>0x48</span>, <span style=color:#2aa198>0x89</span>, <span style=color:#2aa198>0xE5</span>, <span style=color:#586e75>// mov rsp, rbp
</span></span></span></code></pre></div><p>Then we want to back up our callee saved registers that we&rsquo;ll be using. Expect horrific and difficult to debug bugs if you forget to do this.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>  <span style=color:#2aa198>0x41</span>, <span style=color:#2aa198>0x54</span>, <span style=color:#586e75>// pushq %r12
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#2aa198>0x41</span>, <span style=color:#2aa198>0x55</span>, <span style=color:#586e75>// pushq %r13
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#2aa198>0x41</span>, <span style=color:#2aa198>0x56</span>, <span style=color:#586e75>// pushq %r14
</span></span></span></code></pre></div><p>At this point, %rdi will contain the address of memset, %rsi will contain the
address of putchar, and %rdx will contain the address of getchar, see
<a href=/blog/2014/04/18/lets-write-some-x86-64/>x86-64 ABI point #2</a>. We want to store these in callee saved registers before
calling any of them, else they may clobber %rdi, %rsi, or %rdx since they&rsquo;re
not &ldquo;callee saved,&rdquo; rather &ldquo;call clobbered.&rdquo; See
<a href=/blog/2014/04/18/lets-write-some-x86-64/>x86-64 ABI point #4</a>.</p><p><img src=/images/prologue1.png alt=prologue></p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>  <span style=color:#2aa198>0x49</span>, <span style=color:#2aa198>0x89</span>, <span style=color:#2aa198>0xFC</span>, <span style=color:#586e75>// movq %rdi, %r12
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#2aa198>0x49</span>, <span style=color:#2aa198>0x89</span>, <span style=color:#2aa198>0xF5</span>, <span style=color:#586e75>// movq %rsi, %r13
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#2aa198>0x49</span>, <span style=color:#2aa198>0x89</span>, <span style=color:#2aa198>0xD6</span>, <span style=color:#586e75>// movq %rdx, %r14
</span></span></span></code></pre></div><p>At this point, %r12 will contain the address of memset, %r13 will contain the
address of putchar, and %r14 will contain the address of getchar.</p><p><img src=/images/prologue2.png alt=prolog2></p><p>Next up is allocating 30008 B on the stack:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>  <span style=color:#2aa198>0x48</span>, <span style=color:#2aa198>0x81</span>, <span style=color:#2aa198>0xEC</span>, <span style=color:#2aa198>0x38</span>, <span style=color:#2aa198>0x75</span>, <span style=color:#2aa198>0x00</span>, <span style=color:#2aa198>0x00</span>, <span style=color:#586e75>// subq $30008, %rsp
</span></span></span></code></pre></div><p>This is our first hint at how numbers, whose value is larger than the maximum
representable value in a byte, are represented on x86-64. Where in this
instruction is the value 30008? The answer is the 4 byte sequence
<code>0x38, 0x75, 0x00, 0x00</code>. The x86-64 architecture is &ldquo;Little Endian,&rdquo; which
means that the least significant bit (LSB) is first and the most significant
bit (MSB) is last. When humans do math, they typically represent numbers the
other way, or “Big Endian.” Thus we write decimal ten as &ldquo;10&rdquo; and not &ldquo;01.&rdquo;
So that means that <code>0x38, 0x75, 0x00, 0x00</code> in Little Endian is
<code>0x00, 0x00, 0x75, 0x38</code> in Big Endian, which then is
<code>7*16^3+5*16^2+3*16^1+8*16^0</code>
which is <code>30008</code> in decimal, the amount of bytes we want to subtract from the
stack. We&rsquo;re allocating an additional 8 B on the stack for alignment
requirements, similar to the compiler. By pushing even numbers of 64 b
registers, we need to realign our stack pointer.</p><p><img src=/images/prologue3.png alt=prolog3></p><p>Next in the prologue, we set up and call memset:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>  <span style=color:#586e75>// address of beginning of tape
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#2aa198>0x48</span>, <span style=color:#2aa198>0x8D</span>, <span style=color:#2aa198>0x3C</span>, <span style=color:#2aa198>0x24</span>, <span style=color:#586e75>// leaq (%rsp), %rdi
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#586e75>// fill with 0&#39;s
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#2aa198>0xBE</span>, <span style=color:#2aa198>0x00</span>, <span style=color:#2aa198>0x00</span>, <span style=color:#2aa198>0x00</span>, <span style=color:#2aa198>0x00</span>, <span style=color:#586e75>// movl $0, %esi
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#586e75>// length 30,000 B
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#2aa198>0x48</span>, <span style=color:#2aa198>0xC7</span>, <span style=color:#2aa198>0xC2</span>, <span style=color:#2aa198>0x30</span>, <span style=color:#2aa198>0x75</span>, <span style=color:#2aa198>0x00</span>, <span style=color:#2aa198>0x00</span>, <span style=color:#586e75>// movq $30000, %rdx
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#586e75>// memset
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#2aa198>0x41</span>, <span style=color:#2aa198>0xFF</span>, <span style=color:#2aa198>0xD4</span>, <span style=color:#586e75>// callq *%r12
</span></span></span></code></pre></div><p>After invoking memset, %rdi, %rsi, & %rcx will contain garbage values since
they are &ldquo;call clobbered&rdquo; registers. At this point we no longer need memset,
so we now use %r12 as our instruction pointer. %rsp will point to the top
(technically the bottom) of the stack, which is the beginning of our memset&rsquo;ed
tape. That&rsquo;s the end of our prologue.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>  <span style=color:#2aa198>0x49</span>, <span style=color:#2aa198>0x89</span>, <span style=color:#2aa198>0xE4</span> <span style=color:#586e75>// movq %rsp, %r12
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>};
</span></span></code></pre></div><p><img src=/images/prologue4.png alt=prolog4></p><p>We can then push our prologue into our dynamic array implementation:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#268bd2>vector_push</span>(<span style=color:#719e07>&amp;</span>instruction_stream, prologue, <span style=color:#719e07>sizeof</span>(prologue))
</span></span></code></pre></div><p>Now we iterate over our Brainfuck program and switch on the operations again.
For pointer increment and decrement, we just nudge %r12.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;&gt;&#39;</span><span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#dc322f>char</span> opcodes [] <span style=color:#719e07>=</span> {
</span></span><span style=display:flex><span>      <span style=color:#2aa198>0x49</span>, <span style=color:#2aa198>0xFF</span>, <span style=color:#2aa198>0xC4</span> <span style=color:#586e75>// inc %r12
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    };
</span></span><span style=display:flex><span>    <span style=color:#268bd2>vector_push</span>(<span style=color:#719e07>&amp;</span>instruction_stream, opcodes, <span style=color:#719e07>sizeof</span>(opcodes));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;&lt;&#39;</span><span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#dc322f>char</span> opcodes [] <span style=color:#719e07>=</span> {
</span></span><span style=display:flex><span>      <span style=color:#2aa198>0x49</span>, <span style=color:#2aa198>0xFF</span>, <span style=color:#2aa198>0xCC</span> <span style=color:#586e75>// dec %r12
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    };
</span></span><span style=display:flex><span>    <span style=color:#268bd2>vector_push</span>(<span style=color:#719e07>&amp;</span>instruction_stream, opcodes, <span style=color:#719e07>sizeof</span>(opcodes));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#719e07>break</span>;
</span></span></code></pre></div><p>That extra fun block in the switch statement is because in C/C++, we
<a href=http://stackoverflow.com/a/8550253/1027966 target=_blank rel=noopener>can&rsquo;t
define variables in the branches of switch statements</a>.</p><p>Pointer deref then increment/decrement are equally uninspiring:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;+&#39;</span><span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#dc322f>char</span> opcodes [] <span style=color:#719e07>=</span> {
</span></span><span style=display:flex><span>      <span style=color:#2aa198>0x41</span>, <span style=color:#2aa198>0xFE</span>, <span style=color:#2aa198>0x04</span>, <span style=color:#2aa198>0x24</span> <span style=color:#586e75>// incb (%r12)
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    };
</span></span><span style=display:flex><span>    <span style=color:#268bd2>vector_push</span>(<span style=color:#719e07>&amp;</span>instruction_stream, opcodes, <span style=color:#719e07>sizeof</span>(opcodes));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;-&#39;</span><span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#dc322f>char</span> opcodes [] <span style=color:#719e07>=</span> {
</span></span><span style=display:flex><span>      <span style=color:#2aa198>0x41</span>, <span style=color:#2aa198>0xFE</span>, <span style=color:#2aa198>0x0C</span>, <span style=color:#2aa198>0x24</span> <span style=color:#586e75>// decv (%r12)
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    };
</span></span><span style=display:flex><span>    <span style=color:#268bd2>vector_push</span>(<span style=color:#719e07>&amp;</span>instruction_stream, opcodes, <span style=color:#719e07>sizeof</span>(opcodes));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#719e07>break</span>;
</span></span></code></pre></div><p>I/O might be interesting, but in x86-64 we have an opcode for calling the
function at the end of a pointer. %r13 contains the address of putchar while
%r14 contains the address of getchar.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;.&#39;</span><span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#dc322f>char</span> opcodes [] <span style=color:#719e07>=</span> {
</span></span><span style=display:flex><span>      <span style=color:#2aa198>0x41</span>, <span style=color:#2aa198>0x0F</span>, <span style=color:#2aa198>0xB6</span>, <span style=color:#2aa198>0x3C</span>, <span style=color:#2aa198>0x24</span>, <span style=color:#586e75>// movzbl (%r12), %edi
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>      <span style=color:#2aa198>0x41</span>, <span style=color:#2aa198>0xFF</span>, <span style=color:#2aa198>0xD5</span> <span style=color:#586e75>// callq *%r13
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    };
</span></span><span style=display:flex><span>    <span style=color:#268bd2>vector_push</span>(<span style=color:#719e07>&amp;</span>instruction_stream, opcodes, <span style=color:#719e07>sizeof</span>(opcodes));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;,&#39;</span><span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#dc322f>char</span> opcodes [] <span style=color:#719e07>=</span> {
</span></span><span style=display:flex><span>      <span style=color:#2aa198>0x41</span>, <span style=color:#2aa198>0xFF</span>, <span style=color:#2aa198>0xD6</span>, <span style=color:#586e75>// callq *%r14
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>      <span style=color:#2aa198>0x41</span>, <span style=color:#2aa198>0x88</span>, <span style=color:#2aa198>0x04</span>, <span style=color:#2aa198>0x24</span> <span style=color:#586e75>// movb %al, (%r12)
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    };
</span></span><span style=display:flex><span>    <span style=color:#268bd2>vector_push</span>(<span style=color:#719e07>&amp;</span>instruction_stream, opcodes, <span style=color:#719e07>sizeof</span>(opcodes));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#719e07>break</span>;
</span></span></code></pre></div><p>Now with our looping constructs, we get to the fun part. With the compiler, we
deferred the concept of &ldquo;relocation&rdquo; to the assembler. We simply emitted
labels, that the assembler turned into relative offsets (jumps by values
relative to the last byte in the jump instruction). We&rsquo;ve found ourselves in a
Catch-22 though: how many bytes forward do we jump to the matching close
bracket that we haven&rsquo;t seen yet?</p><p>Normally, an assembler might have a data structure known as a
&ldquo;relocation table.&rdquo; It keeps track of the first byte after a label and jumps,
rewriting jumps-to-labels (which aren&rsquo;t kept around in the resulting binary
executable) to relative jumps. Spidermonkey, Firefox&rsquo;s JavaScript Virtual
Machine has two classes for this,
<a href=http://mxr.mozilla.org/mozilla-central/source/js/src/jit/MacroAssembler.cpp target=_blank rel=noopener>MacroAssembler</a> and
<a href=http://mxr.mozilla.org/mozilla-central/source/js/src/jit/Label.h target=_blank rel=noopener>Label</a>. Spidermonkey
embeds a linked list in the opcodes it generates for jumps with which it&rsquo;s yet
to see a label for. Once it finds the label, it walks the linked list (which
itself is embedded in the emitted instruction stream) patching up these
locations as it goes.</p><p>For Brainfuck, we don&rsquo;t have to anything quite as fancy since each label only
ends up having one jump site. Instead, we can use a stack of integers that are
offsets into our dynamic array, and do the relocation once we know where
exactly we&rsquo;re jumping to.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;[&#39;</span><span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#dc322f>char</span> opcodes [] <span style=color:#719e07>=</span> {
</span></span><span style=display:flex><span>      <span style=color:#2aa198>0x41</span>, <span style=color:#2aa198>0x80</span>, <span style=color:#2aa198>0x3C</span>, <span style=color:#2aa198>0x24</span>, <span style=color:#2aa198>0x00</span>, <span style=color:#586e75>// cmpb $0, (%r12)
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>      <span style=color:#586e75>// Needs to be patched up
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>      <span style=color:#2aa198>0x0F</span>, <span style=color:#2aa198>0x84</span>, <span style=color:#2aa198>0x00</span>, <span style=color:#2aa198>0x00</span>, <span style=color:#2aa198>0x00</span>, <span style=color:#2aa198>0x00</span> <span style=color:#586e75>// je &lt;32b relative offset, 2&#39;s compliment, LE&gt;
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    };
</span></span><span style=display:flex><span>    <span style=color:#268bd2>vector_push</span>(<span style=color:#719e07>&amp;</span>instruction_stream, opcodes, <span style=color:#719e07>sizeof</span>(opcodes));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#268bd2>stack_push</span>(<span style=color:#719e07>&amp;</span>relocation_table, instruction_stream.size); <span style=color:#586e75>// create a label after
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#719e07>break</span>;
</span></span></code></pre></div><p>First we push the compare and jump opcodes, but for now we leave the relative
offset blank (four zero bytes). We will come back and patch it up later.
Then, we push the current length of dynamic array, which just so happens to be
the offset into the instruction stream of the next instruction.</p><p>All of the relocation magic happens in the case for the closing bracket.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;]&#39;</span><span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#dc322f>char</span> opcodes [] <span style=color:#719e07>=</span> {
</span></span><span style=display:flex><span>      <span style=color:#2aa198>0x41</span>, <span style=color:#2aa198>0x80</span>, <span style=color:#2aa198>0x3C</span>, <span style=color:#2aa198>0x24</span>, <span style=color:#2aa198>0x00</span>, <span style=color:#586e75>// cmpb $0, (%r12)
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>      <span style=color:#586e75>// Needs to be patched up
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>      <span style=color:#2aa198>0x0F</span>, <span style=color:#2aa198>0x85</span>, <span style=color:#2aa198>0x00</span>, <span style=color:#2aa198>0x00</span>, <span style=color:#2aa198>0x00</span>, <span style=color:#2aa198>0x00</span> <span style=color:#586e75>// jne &lt;33b relative offset, 2&#39;s compliment, LE&gt;
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    };
</span></span><span style=display:flex><span>    <span style=color:#268bd2>vector_push</span>(<span style=color:#719e07>&amp;</span>instruction_stream, opcodes, <span style=color:#719e07>sizeof</span>(opcodes));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#586e75>// ...
</span></span></span></code></pre></div><p>First, we push our comparison and jump instructions into the dynamic array.
We should know the relative offset we need to jump back to at this point, and
thus don&rsquo;t need to push four empty bytes, but it makes the following math a
little simpler, as were not done yet with this case.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>  <span style=color:#586e75>// ...
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#268bd2>stack_pop</span>(<span style=color:#719e07>&amp;</span>relocation_table, <span style=color:#719e07>&amp;</span>relocation_site);
</span></span><span style=display:flex><span>  relative_offset <span style=color:#719e07>=</span> instruction_stream.size <span style=color:#719e07>-</span> relocation_site;
</span></span><span style=display:flex><span>  <span style=color:#586e75>// ...
</span></span></span></code></pre></div><p><img src=/images/relative_jump_unknown.png alt="relative jump unknown"></p><p>We pop the matching offset into the dynamic array (from the matching open
bracket), and calculate the difference from the current size of the instruction
stream to the matching offset to get our relative offset. What&rsquo;s interesting
is that this offset is equal in magnitude for the forward and backwards jumps
that we now need to patch up. We simply go back in our instruction stream 4 B,
and write that relative offset negated as a 32 b LE number (patching our
backwards jump), then go back to the site of our forward jump minus 4 B and
write that relative offset as a 32 b LE number (patching our forwards jump).</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>  <span style=color:#586e75>// ...
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#268bd2>vector_write32LE</span>(<span style=color:#719e07>&amp;</span>instruction_stream, instruction_stream.size <span style=color:#719e07>-</span> <span style=color:#2aa198>4</span>, <span style=color:#719e07>-</span>relative_offset);
</span></span><span style=display:flex><span>  <span style=color:#268bd2>vector_write32LE</span>(<span style=color:#719e07>&amp;</span>instruction_stream, relocation_site <span style=color:#719e07>-</span> <span style=color:#2aa198>4</span>, relative_offset);
</span></span><span style=display:flex><span>  <span style=color:#719e07>break</span>;
</span></span></code></pre></div><p>Thus, when writing a JIT, one must worry about manual relocation. From the
<a href=http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf target=_blank rel=noopener>Intel 64 and IA-32 Architectures Software Developer’s Manual Volume 2 (2A, 2B & 2C): Instruction Set Reference, A-Z</a> &ldquo;A relative offset
(rel8, rel16, or rel32) is generally specified as a label in assembly code, but
at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate
value, which is added to the instruction pointer.&rdquo;</p><p>The last thing we push onto our instruction stream is clean up code in the
epilogue.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#dc322f>char</span> epilogue [] <span style=color:#719e07>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#2aa198>0x48</span>, <span style=color:#2aa198>0x81</span>, <span style=color:#2aa198>0xC4</span>, <span style=color:#2aa198>0x38</span>, <span style=color:#2aa198>0x75</span>, <span style=color:#2aa198>0x00</span>, <span style=color:#2aa198>0x00</span>, <span style=color:#586e75>// addq $30008, %rsp
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#586e75>// restore callee saved registers
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#2aa198>0x41</span>, <span style=color:#2aa198>0x5E</span>, <span style=color:#586e75>// popq %r14
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#2aa198>0x41</span>, <span style=color:#2aa198>0x5D</span>, <span style=color:#586e75>// popq %r13
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#2aa198>0x41</span>, <span style=color:#2aa198>0x5C</span>, <span style=color:#586e75>// popq %r12
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#2aa198>0x5d</span>, <span style=color:#586e75>// pop rbp
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#2aa198>0xC3</span> <span style=color:#586e75>// ret
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>};
</span></span><span style=display:flex><span><span style=color:#268bd2>vector_push</span>(<span style=color:#719e07>&amp;</span>instruction_stream, epilogue, <span style=color:#719e07>sizeof</span>(epilogue));
</span></span></code></pre></div><p>A dynamic array of bytes isn&rsquo;t really useful, so we need to create executable
memory the size of the current instruction stream and copy all of the machine
opcodes into it, cast it to a function pointer, call it, and finally clean up:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#dc322f>void</span><span style=color:#719e07>*</span> mem <span style=color:#719e07>=</span> <span style=color:#268bd2>mmap</span>(<span style=color:#b58900>NULL</span>, instruction_stream.size, PROT_WRITE <span style=color:#719e07>|</span> PROT_EXEC,
</span></span><span style=display:flex><span>  MAP_ANON <span style=color:#719e07>|</span> MAP_PRIVATE, <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>, <span style=color:#2aa198>0</span>);
</span></span><span style=display:flex><span><span style=color:#268bd2>memcpy</span>(mem, instruction_stream.data, instruction_stream.size);
</span></span><span style=display:flex><span><span style=color:#dc322f>void</span> (<span style=color:#719e07>*</span>jitted_func) (fn_memset, fn_putchar, fn_getchar) <span style=color:#719e07>=</span> mem;
</span></span><span style=display:flex><span><span style=color:#268bd2>jitted_func</span>(memcpy, putchar, getchar);
</span></span><span style=display:flex><span><span style=color:#268bd2>munmap</span>(mem, instruction_stream.size);
</span></span><span style=display:flex><span><span style=color:#268bd2>vector_destroy</span>(<span style=color:#719e07>&amp;</span>instruction_stream);
</span></span></code></pre></div><p>Note: we could have used the instruction stream rewinding technique to move the address of memset, putchar, and getchar as 64 b immediate values into %r12-%r14, which would have
<a href=https://github.com/nickdesaulniers/bf_interpreter_jit_compiler/pull/6/files target=_blank rel=noopener>simplified our JIT&rsquo;d function&rsquo;s type signature</a>.</p><p>Compile that, and we now have
<a href=https://github.com/nickdesaulniers/bf_interpreter_jit_compiler/blob/master/jit.c target=_blank rel=noopener>a function that will JIT compile and execute Brainfuck in roughly 141 SLOC</a>. And, we can make changes to our Brainfuck program and not have to recompile it like we did with the Brainfuck compiler.</p><p>Hopefully it&rsquo;s becoming apparent how similar an interpreter, compiler, and JIT
behave. In the interpreter, we immediately execute some operation. In the
compiler, we emit the equivalent text based assembly instructions corresponding
to what the higher level language might get translated to in the interpreter.
In the JIT, we emit the binary opcodes into executable memory and manually
perform relocation, where the binary opcodes are equivalent to the text based
assembly we might emit in the compiler. A production ready JIT would probably have macros for each operation in the JIT would perform, so the code would look more like the compiler rather than raw arrays of bytes (though the preprocessor would translate those macros into such). The entire process is basically disassembling C code with <code>gobjdump -S -M suffix a.out</code>, and punching in hex like one would a Gameshark.</p><p>Compare pointer incrementing from the three:</p><p>Interpreter:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;&gt;&#39;</span><span style=color:#719e07>:</span> <span style=color:#719e07>++</span>ptr; <span style=color:#719e07>break</span>;
</span></span></code></pre></div><p>Compiler:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;&gt;&#39;</span><span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>  <span style=color:#268bd2>puts</span>(<span style=color:#2aa198>&#34;  inc %r12&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#719e07>break</span>;
</span></span></code></pre></div><p>JIT:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>case</span> <span style=color:#2aa198>&#39;&gt;&#39;</span><span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#dc322f>char</span> opcodes [] <span style=color:#719e07>=</span> {
</span></span><span style=display:flex><span>      <span style=color:#2aa198>0x49</span>, <span style=color:#2aa198>0xFF</span>, <span style=color:#2aa198>0xC4</span> <span style=color:#586e75>// inc %r12
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    };
</span></span><span style=display:flex><span>    <span style=color:#268bd2>vector_push</span>(<span style=color:#719e07>&amp;</span>instruction_stream, opcodes, <span style=color:#719e07>sizeof</span>(opcodes));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#719e07>break</span>;
</span></span></code></pre></div><p>Or compare the full sources of the
<a href=https://github.com/nickdesaulniers/bf_interpreter_jit_compiler/blob/master/interpreter.c target=_blank rel=noopener>the interpreter</a>,
<a href=https://github.com/nickdesaulniers/bf_interpreter_jit_compiler/blob/master/compiler.c target=_blank rel=noopener>the compiler</a>, and
<a href=https://github.com/nickdesaulniers/bf_interpreter_jit_compiler/blob/master/jit.c target=_blank rel=noopener>the JIT</a>. Each at ~100 lines of code should be fairly easy to digest.</p><p>Let&rsquo;s now examine the performance of these three. One of the longer running
Brainfuck programs I can find is
<a href=https://github.com/nickdesaulniers/bf_interpreter_jit_compiler/blob/master/samples/mandelbrot.b target=_blank rel=noopener>one that prints the Mandelbrot set as ASCII art to stdout</a>.</p><video controls preload=auto playsinline class=html-video>
<source src=/video/jit.mp4 type=video/webm></video><p>Running the UNIX command <code>time</code> on the interpreter, compiled
result, and the JIT, we should expect numbers similar to:</p><pre tabindex=0><code>$ time ./interpreter ../samples/mandelbrot.b
43.54s user 0.03s system 99% cpu 43.581 total

$ ./compiler ../samples/mandelbrot.b &gt; temp.s; ../assemble.sh temp.s; time ./a.out
3.24s user 0.01s system 99% cpu 3.254 total

$ time ./jit ../samples/mandelbrot.b
3.27s user 0.01s system 99% cpu 3.282 total
</code></pre><p>The interpreter is an order of magnitude slower than the compiled result or run
of the JIT. Then again, the interpreter isn&rsquo;t able to jump back and forth as
efficiently as the compiler or JIT, since it scans back and forth for matching
brackets O(N), while the other two can jump to where they need to go in a few instructions O(1). A production interpreter would probably translate the higher level language to a byte code, and thus be able to calculate the offsets used for jumps directly, rather than scanning back and forth.</p><p>The interpreter bounces back and forth between looking up an operation, then
doing something based on the operation, then lookup, etc.. The compiler and JIT preform the translation first, then the execution, not interleaving the two.</p><p>The compiled result is the fastest, as expected, since it doesn&rsquo;t have the
overhead the JIT does of having to read the input file or build up the
instructions to execute at runtime. The compiler has read
and translated the input file ahead of time.</p><p>What if we take into account the
time it takes to compile the source code, and run it?</p><pre tabindex=0><code>$ time (./compiler ../samples/mandelbrot.b &gt; temp.s; ../assemble.sh temp.s; ./a.out)
3.27s user 0.08s system 99% cpu 3.353 total
</code></pre><p>Including the time it takes to compile the code then run it, the compiled
results are now slightly slower than the JIT (though I bet the multiple processes we start up are suspect), but with the JIT we pay the price
to compile each and every time we run our code. With the compiler, we pay that
tax once. When compilation time is cheap, as is the case with our Brainfuck
compiler & JIT, it makes sense to prefer the JIT; it allows us to quickly make
changes to our code and re-run it. When compilation is expensive, we might
only want to pay the compilation tax once, especially if we plan on running the
program repeatedly.</p><p>JIT&rsquo;s are neat but compared to compilers can be more complex to
implement. They also repeatedly re-parse input files and re-build instruction
streams at runtime. Where they can shine is bridging the gap for dynamically
typed languages where the runtime itself is much more dynamic, and thus harder
(if not, impossible) to optimize ahead of time. Being able to jump into JIT&rsquo;d
native code from an
interpreter and back gives you the best of both (interpreted and compiled)
worlds.</p></div><footer><p class=meta><span class="byline author vcard">Posted by <span class=fn>Nick Desaulniers</span></span>
<time>May 25, 2015</time></span></p><p class=meta><a class="basic-alignment left" href=https://nickdesaulniers.github.io/blog/2015/02/22/public-key-crypto-code-example/ title="Hidden in Plain Sight - Public Key Crypto">Hidden in Plain Sight - Public Key Crypto</a>
<a class="basic-alignment right" href=https://nickdesaulniers.github.io/blog/2015/07/23/additional-c-slash-c-plus-plus-tooling/ title="Additional C/C++ Tooling">Additional C/C++ Tooling</a></p><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//wangstabill.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></div><aside class="sidebar thirds"><section class="first odd"><p></p></section><ul class=sidebar-nav><li class=sidebar-nav-item><a target=_blank rel="noopener noreferrer" href=https://github.com/nickdesaulniers title=https://github.com/nickdesaulniers><i class="fa fa-github fa-3x"></i></a>
<a target=_blank rel="me noopener noreferrer" href=https://fosstodon.org/@llvm title=https://fosstodon.org/@llvm><i class="fa fa-mastodon fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href=https://www.linkedin.com/in/nick-desaulniers-75520334 title=https://www.linkedin.com/in/nick-desaulniers-75520334><i class="fa fa-linkedin fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href=https://www.youtube.com/channel/UC68vgKSuS1Xjg9wpdvShfSQ title=https://www.youtube.com/channel/UC68vgKSuS1Xjg9wpdvShfSQ><i class="fa fa-youtube fa-3x"></i></a></li></ul><section class=even><h1>Recent Posts</h1><ul id=recent_posts><li class=post><a href=/blog/2023/03/10/usps-as-an-isp/>USPS as an ISP</a></li><li class=post><a href=/blog/2023/03/10/disambiguating-arm/>Disambiguating Arm, Arm ARM, ARMv9, ARM9, ARM64, Aarch64, A64, A78, ...</a></li><li class=post><a href=/blog/2023/02/01/forking-is-not-free-the-hidden-costs/>Forking is not free; the hidden costs</a></li><li class=post><a href=/blog/2023/01/27/critical-edge-splitting/>Critical Edge Splitting</a></li></ul></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2023 Nick Desaulniers - <a href=https://nickdesaulniers.github.io/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.</p></footer><script>var _gaq=[["_setAccount","UA-36993986-1"],["_trackPageview"]];(function(e,t){var n=e.createElement(t),s=e.getElementsByTagName(t)[0];n.src=("https:"==location.protocol?"//ssl":"//www")+".google-analytics.com/ga.js",s.parentNode.insertBefore(n,s)})(document,"script")</script></body></html>