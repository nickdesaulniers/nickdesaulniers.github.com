<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=/css/fonts.css rel=stylesheet type=text/css><title>Disambiguating Arm, Arm ARM, ARMv9, ARM9, ARM64, Aarch64, A64, A78, ...</title><link rel=stylesheet href=/css/hugo-octopress.css><link rel=stylesheet href=https://nickdesaulniers.github.io/css/custom.css><link rel=stylesheet href=/css/fork-awesome.min.css><link href=https://nickdesaulniers.github.io/favicon.ico rel=icon><meta name=description content><meta name=keywords content><meta name=author content="Nick Desaulniers"><meta name=generator content="Hugo 0.109.0"></head><body><header role=banner><hgroup><h1><a href=https://nickdesaulniers.github.io/>Nick Desaulniers</a></h1><h2>The enemy's gate is down</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value"><option value>Navigate…</option><option value=https://nickdesaulniers.github.io/about/>» About</option><option value=https://nickdesaulniers.github.io/blog/archives/>» Archives</option><option value=https://nickdesaulniers.github.io/>» Blog</option><option value=https://nickdesaulniers.github.io/publications/>» Publications</option><option value=https://nickdesaulniers.github.io/talks/>» Talks</option></select></fieldset><ul class=main-navigation><li><a href=https://nickdesaulniers.github.io/about/ title=About rel="noopener noreferrer">About</a></li><li><a href=https://nickdesaulniers.github.io/blog/archives/ title=Archives rel="noopener noreferrer">Archives</a></li><li><a href=https://nickdesaulniers.github.io/ title=Blog>Blog</a></li><li><a href=https://nickdesaulniers.github.io/publications/ title=Publications rel="noopener noreferrer">Publications</a></li><li><a href=https://nickdesaulniers.github.io/talks/ title=Talks rel="noopener noreferrer">Talks</a></li></ul><ul class=subscription><a href=https://nickdesaulniers.github.io/index.xml target=_blank type=application/rss+xml title=RSS rel="noopener noreferrer"><i class="fa fa-rss-square fa-lg"></i></a></ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer"><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:https://nickdesaulniers.github.io/></fieldset></form></nav><div id=main><div id=content><div><article class=hentry role=article><header><p class=meta>Mar 10, 2023
- 8 minute read
- <a href=https://nickdesaulniers.github.io/blog/2023/03/10/disambiguating-arm/#disqus_thread>Comments</a>
- <a class=label href=https://nickdesaulniers.github.io/categories/arm/>ARM</a></p><h1 class=entry-title>Disambiguating Arm, Arm ARM, ARMv9, ARM9, ARM64, Aarch64, A64, A78, ...</h1></header><div class=entry-content><p>If you&rsquo;re new to the Arm ecosystem, consider this a quick primer on terms you
likely have seen before but might have questions about.</p><p>The <strong>Arm</strong> architecture is a family of Reduced Instruction Set Architectures
(RISC) with simple addressing modes. Data processing is done on register
operands otherwise relying on loads and stores to move data into and out of
registers.</p><p><strong>Arm</strong> Limited,
<a href=https://www.arm.com/company target=_blank rel=noopener>the British company</a>,
stewards the Arm architecture.</p><p>ARM is a legacy acronym for Acorn RISC Machine, then Advanced RISC Machines.
As we&rsquo;ll see, with new advancements in the architecture, previous terms for
things sometimes get renamed.</p><p><a href=https://developer.arm.com/documentation/ddi0487/latest target=_blank rel=noopener>The Arm Architectural Reference Manual for A-profile architecture</a>,
affectionately referred to as the <strong>Arm ARM</strong>, is <em>the</em> programming manual for
the architecture. If you&rsquo;re doing anything with Arm assembly, you probably have
this reference nearby.</p><p><strong><a href=https://www.anandtech.com/show/16584/arm-announces-armv9-architecture target=_blank rel=noopener>ARMv9</a></strong>
is the latest (as of this writing) in the family of architectures,
featuring additions such as newer scalable SIMD vector (SVE2) and matrix
(SME/SME2) operations and tracing functionality.</p><p><strong>ARMv9.4-A</strong> is the latest batch of extensions to ARMv9. These extensions are
documented in the Arm ARM. Some extensions are optional when introduced and
many become mandatory in future revisions if they weren&rsquo;t already when
introduced.</p><p>The <em>A</em> in <strong>ARMv9-A</strong> denotes the &ldquo;Application Profile.&rdquo; These support virtual
memory via memory management units, and are what you&rsquo;re likely to find on any
Arm systems such as a phone, laptop, or server. There&rsquo;s also the &ldquo;R&rdquo; profile
for applications with real time system requirements, and &ldquo;M&rdquo; profiles which
you&rsquo;re more likely to find in microcontrollers which lack MMUs. The three
<em><a href=https://developer.arm.com/documentation/dui0471/m/key-features-of-arm-architecture-versions/arm-architecture-profiles target=_blank rel=noopener>architectural profiles</a></em>
are A, R, and M.</p><p><strong>AArch64</strong> is an <em>execution state</em> and was one of the larger additions with
the introduction of ARMv8, which added support for 64b registers (31 general
purpose registers, dedicated 64b stack pointer, 64b program counter that cannot
be written to other than by branches or exceptions, and a zero-value
<a href=https://developer.arm.com/documentation/den0024/a/An-Introduction-to-the-ARMv8-Instruction-Sets/The-ARMv8-instruction-sets/Registers target=_blank rel=noopener>pseudo-register</a>)
and addressing. At the same time, the <strong>AArch32</strong> execution state
was coined to refer to the legacy 32b functionality that folks were familiar
with from ARMv7 (15 32b GPRs, no dedicated SP, PC is writable).</p><p>Curiously, the Arm ARM doesn&rsquo;t mention the term <strong>ARM64</strong>; that seems to be a
term preferred by
<a href=https://developer.apple.com/documentation/xcode/writing-arm64-code-for-apple-platforms target=_blank rel=noopener>Apple</a>,
<a href=https://learn.microsoft.com/en-us/windows/arm/overview target=_blank rel=noopener>Microsoft</a>,
and
<a href="https://lore.kernel.org/lkml/CA+55aFxL6uEre-c=JrhPfts=7BGmhb2Js1c2ZGkTH8F=+rEWDg@mail.gmail.com/" target=_blank rel=noopener>Linus Torvalds</a>
(that thread will always make me laugh, the maintainers of the port ultimately
decided to use
<a href=https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64 target=_blank rel=noopener><em>arm64</em> in the tree</a>.
The name ultimately makes sense; the arm64
Linux kernel port can execute userspace code in AArch64 or AArch32 <em>execution
states</em>, though the kernel itself is AArch64-only).</p><p>If you want to learn about the calling convention (arguments are passed in
which registers) used on these Arm systems, you might read the <em>Procedure Call
Standard for the Arm Architecture</em> (aka <strong>AAPCS</strong>), which is published along
with other documentation related to the ABI
<a href=https://github.com/ARM-software/abi-aa/releases target=_blank rel=noopener>here</a>.
This made the previous <em>APCS</em> and <em>TPCS</em> standards obsolete. Apple platforms
<a href=https://developer.apple.com/documentation/xcode/writing-arm64-code-for-apple-platforms target=_blank rel=noopener>diverge</a>
from Arm&rsquo;s ABI in specific ways. Microsoft also
<a href=https://learn.microsoft.com/en-us/cpp/build/arm64-windows-abi-conventions target=_blank rel=noopener>has docs</a>
(starting with a nice definition list like this post) on their ABI for Windows.</p><p><strong>A64</strong> is the instruction set introduced with <em>AArch64</em>. In fact, it is the
only <em>instruction set</em> supported by <em>AArch64</em>. While registers in the <em>AArch64
execution state</em> are 64b, the instructions themselves are still only 32b (fixed
width). <strong>A32</strong> now refers to the older ISA, which was also 32b fixed width
while T32 refers to the mixed 32b and 16b Thumb2 instructions. You may be
familiar with those ISAs if you&rsquo;ve worked with ARMv7 or older devices. <em>A64</em> is
a clean break from <em>A32</em> and is a familiar but different ISA. For instance,
much fewer instructions support predication in <em>A64</em> than <em>A32</em>.</p><p>Not to be confused with <em>A64</em>, you might hear someone refer to a core as &ldquo;being
an <em>A78</em>,&rdquo; or more formally <strong>Cortex-A78</strong>. Not only does Arm design the Arm
architecture, but
<a href=https://www.anandtech.com/show/7112/the-arm-diaries-part-1-how-arms-business-model-works target=_blank rel=noopener>they also design</a>
implementations of the architecture which we call micro architectures.
Regardless of the number that follows, if you see the terms <em>Cortex</em> or
<em>Neoverse</em>, those are Arm-designed microarchitectures of the Arm architecture.
<em>Cortex-A78</em> for instance implements up to ARMv8.3 extensions. Wikipedia has
<a href=https://en.wikipedia.org/wiki/Template:Application_ARM-based_chips target=_blank rel=noopener>a template</a>
that is a quick reference to the most recent Arm microarchitectures. Before we
can talk more about microarchitectures in the Arm realm, we need to detour to
topologies.</p><p><em>DynamIQ</em> (and <em>big.LITTLE</em> before that) build upon the idea of using heterogeneous
(different) cores rather than homogeneous (similar) cores for multi-core
systems. I&rsquo;m not sure this could still be considered <em>symmetric</em> multiprocessing.
The advantage of this design is the flexibility to be good at different things
at different times. We want large power hungry out of order processors to
improve performance when we need it, but we might prefer slower in-order cores
to help save power consumption (which would improve battery life). It&rsquo;s
interesting to see Intel doing something vaguely similar with the introduction
of <em>performance</em> and <em>efficiency</em> cores in their
<a href=https://fuse.wikichip.org/news/6115/intel-unveils-alder-lake-next-generation-mainstream-heterogeneous-multi-core-soc/ target=_blank rel=noopener>Alder Lake</a>
microarchitecture.</p><p>By digging through the Technical Reference Manuals published by Arm for various
microarchitectures, we can see an interesting evolution of support for various
<em>execution states</em> with regards to various exception levels over time.</p><ul><li><a href=https://developer.arm.com/documentation/100442/0200/Functional-description/Introduction/Features target=_blank rel=noopener>A55</a>:
&ldquo;Both the AArch32 and AArch64 execution states at all Exception levels (EL0
to EL3).&rdquo;</li><li><a href=https://developer.arm.com/documentation/101433/r1p2/Functional-description/Introduction/Features target=_blank rel=noopener>X1</a>:
&ldquo;AArch32 Execution state at Exception level EL0 only. AArch64 Execution
state at all Exception levels (EL0 to EL3)&rdquo;</li><li><a href=https://developer.arm.com/documentation/101593/0102/The-Cortex-X3--core/Cortex-X3--core-features target=_blank rel=noopener>X3</a>:
&ldquo;AArch64 Execution state at all Exception levels, EL0 to EL3.&rdquo; [i.e. no
AArch32 support]</li></ul><p>If an SoC were to be composed of heterogeneous cores with varying levels of
AArch32 support, that
<a href=https://blog.esper.io/android-dessert-bites-3-road-to-64-bit-3123759/ target=_blank rel=noopener>would place interesting constraints on the operating system&rsquo;s process scheduler</a>;
you can&rsquo;t run an AArch32 program on a core that doesn&rsquo;t support it!</p><hr><p>Below are some more legacy terms. They might still be relevant, depending on
how old some systems you still support are.</p><p><strong>ARM9</strong> (not to be confused with <em>ARMv9</em>, the version of the architecture) is
a family of cores, some implementing ARMv4t, some ARMv5.</p><p><em><a href=https://en.wikipedia.org/wiki/StrongARM target=_blank rel=noopener>StrongARM</a></em>
was a series of ARMv4 CPUs built by Digital Equipment Corporation;
Intel acquired this IP as part of a settlement of a lawsuit, and eventually
designed their own ARMv5 microarchitecture called
<em><a href=https://en.wikipedia.org/wiki/XScale target=_blank rel=noopener>XScale</a></em>.
Eventually Intel
<a href=https://en.wikipedia.org/wiki/XScale#Sale_of_PXA_processor_line target=_blank rel=noopener>sold</a>
the PXA SoC family which was using XScale to Marvell. One wonders
<a href=https://techcrunch.com/2016/05/17/how-intel-missed-the-iphone-revolution/ target=_blank rel=noopener>what the world may have looked like</a>
had Intel stuck with XScale in addition to or instead of Atom.</p><p>ARMv4t introduced a compressed instruction set called <strong>Thumb</strong>. Instructions were
16b fixed width (that said, there were some oddities like
<a href=https://developer.arm.com/documentation/ddi0308/d/Thumb-Instructions/Alphabetical-list-of-Thumb-instructions/BL--BLX--immediate- target=_blank rel=noopener>BL and BLX that were actually encoded as a pair of 16b instructions each</a>;
implementations had to take care that exception returns worked correctly if an
exception occurred in the middle of the pair; it was implementation defined if
that could even occur).</p><p>ARMv6t2 introduced <strong>Thumb2</strong> which added more instructions including some 32b
wide instructions to support wider immediates, new instruction suffixes to
differentiate between <em>narrow</em> vs <em>wide</em> encodings, and a Unified Assembly
Language (UAL) that made it easier to write assembler that was valid in Arm or
Thumb mode. This made Thumb no longer fixed width though. The introduction of
<em>execution states</em> with ARMv8 renamed Thumb to <em>T32</em>; there was no such <em>T32</em>
term when these instructions were introduced!</p><p>You may come across the term <em>aarch64be</em> being used in the context of toolchains,
which is referring to big-endian. Arm has supported bi-endianness
<a href=https://doc.rust-lang.org/rustc/platform-support/armeb-unknown-linux-gnueabi.html target=_blank rel=noopener>since ARMv4</a>,
though most platforms these days use Arm in little-endian endian configuration.
Big-endian is more common in networking appliances since network byte order is
BE. <code>-mlittle-endian</code> and <code>-mbig-endian</code> are the compiler flags one might use
to control codegen. ARMv4 and v5 supported a <strong>BE-32</strong> <em>bus byte ordering</em>.
Code linked with
<a href=https://developer.arm.com/documentation/dui0493/g/linker-command-line-options/--be32 target=_blank rel=noopener><code>--be32</code></a>
produced big-endian code and data. ARMv6 added a new
bus byte ordering called <em>BE-8</em>.
<a href=https://developer.arm.com/documentation/dui0493/g/linker-command-line-options/--be8 target=_blank rel=noopener><code>--be8</code></a>
produced little-endian code and big-endian data (the compiler would emit
big-endian code for relocatable files when built with <code>-big-endian</code>, then the
linker would convert these to little endian when <code>--be8</code> was used. This allowed
compilers to not worry about byte-reversing code regardless of what bus byte
ordering was to be used at the expense of linker complexity). ARMv6 had both
<a href=https://developer.arm.com/documentation/ddi0290/g/unaligned-and-mixed-endian-data-access-support/mixed-endian-access-support/differences-between-be-32-and-be-8-buses target=_blank rel=noopener>BE-32 and BE-8 bus byte orderings</a>
(the older BE-32 became optional), though
<a href=https://developer.arm.com/documentation/ddi0406/cb/Appendixes/Deprecated-and-Obsolete-Features/Obsolete-features/Support-for-BE-32-endianness-model target=_blank rel=noopener>ARMv7 removed support for BE-32</a>.
<a href=https://blog.richliu.com/2010/04/08/907/arm11-be8-and-be32/ target=_blank rel=noopener>This post</a>
shows why BE-8 replaced BE-32; it was simpler to support systems of both
endiannesses if we used little endian instructions and had the memory bus
reorder the bytes on access. ELF uses the file format identifiers
elf64-littleaarch64, elf64-bigaarch64, elf32-littlearm, and elf32-bigarm;
though those identifiers don&rsquo;t appear in
<a href=https://github.com/ARM-software/abi-aa/releases target=_blank rel=noopener>ELF for the Arm {64-bit} Architecture</a>.</p><p>That&rsquo;s a quick glossary over common terms related to the Arm ecosystem.
Hopefully in a follow up post we can review terms like VFP, NEON, OABI, and
EABI, but these are enough for now.</p><p>Many thanks to my friends Peter Smith, Kristof Beyls, and Mark Brown of Arm,
Arnd Bergmann of Linaro, and Ard Biesheuvel of Google, for proofreading drafts
of this post and supplying insightful feedback. Coincidentally, while I was
taking my time editing this post, my friend and colleague Fangrui Song
<a href=https://maskray.me/blog/2023-03-05-linker-notes-on-aarch64 target=_blank rel=noopener>beat me to the punch</a>
which another great blog post touching on very similar topics; you should check
out
<a href=https://maskray.me/blog/ target=_blank rel=noopener>his blog</a>
if you like this kind of content!</p></div><footer><p class=meta><span class="byline author vcard">Posted by <span class=fn>Nick Desaulniers</span></span>
<time>Mar 10, 2023</time></span></p><p class=meta><a class="basic-alignment left" href=https://nickdesaulniers.github.io/blog/2023/02/01/forking-is-not-free-the-hidden-costs/ title="Forking is not free; the hidden costs">Forking is not free; the hidden costs</a>
<a class="basic-alignment right" href=https://nickdesaulniers.github.io/blog/2023/03/10/usps-as-an-isp/ title="USPS as an ISP">USPS as an ISP</a></p><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//wangstabill.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></div><aside class="sidebar thirds"><section class="first odd"><p></p></section><ul class=sidebar-nav><li class=sidebar-nav-item><a target=_blank rel="noopener noreferrer" href=https://github.com/nickdesaulniers title=https://github.com/nickdesaulniers><i class="fa fa-github fa-3x"></i></a>
<a target=_blank rel="me noopener noreferrer" href=https://fosstodon.org/@llvm title=https://fosstodon.org/@llvm><i class="fa fa-mastodon fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href=https://www.linkedin.com/in/nick-desaulniers-75520334 title=https://www.linkedin.com/in/nick-desaulniers-75520334><i class="fa fa-linkedin fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href=https://www.youtube.com/channel/UC68vgKSuS1Xjg9wpdvShfSQ title=https://www.youtube.com/channel/UC68vgKSuS1Xjg9wpdvShfSQ><i class="fa fa-youtube fa-3x"></i></a></li></ul><section class=even><h1>Recent Posts</h1><ul id=recent_posts><li class=post><a href=/blog/2023/03/10/usps-as-an-isp/>USPS as an ISP</a></li><li class=post><a href=/blog/2023/03/10/disambiguating-arm/>Disambiguating Arm, Arm ARM, ARMv9, ARM9, ARM64, Aarch64, A64, A78, ...</a></li><li class=post><a href=/blog/2023/02/01/forking-is-not-free-the-hidden-costs/>Forking is not free; the hidden costs</a></li><li class=post><a href=/blog/2023/01/27/critical-edge-splitting/>Critical Edge Splitting</a></li></ul></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2023 Nick Desaulniers - <a href=https://nickdesaulniers.github.io/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.</p></footer><script>var _gaq=[["_setAccount","UA-36993986-1"],["_trackPageview"]];(function(e,t){var n=e.createElement(t),s=e.getElementsByTagName(t)[0];n.src=("https:"==location.protocol?"//ssl":"//www")+".google-analytics.com/ga.js",s.parentNode.insertBefore(n,s)})(document,"script")</script></body></html>