<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=/css/fonts.css rel=stylesheet type=text/css><title>Debugging -Wframe-larger-than=</title><link rel=stylesheet href=/css/hugo-octopress.css><link rel=stylesheet href=https://nickdesaulniers.github.io/css/custom.css><link rel=stylesheet href=/css/fork-awesome.min.css><link href=https://nickdesaulniers.github.io/favicon.png rel=icon><meta name=description content><meta name=keywords content><meta name=author content="Nick Desaulniers"><meta name=generator content="Hugo 0.109.0"></head><body><header role=banner><hgroup><h1><a href=https://nickdesaulniers.github.io/>Nick Desaulniers</a></h1><h2>The enemy's gate is down</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value"><option value>Navigate…</option><option value=https://nickdesaulniers.github.io/about/>» About</option><option value=https://nickdesaulniers.github.io/blog/archives/>» Archives</option><option value=https://nickdesaulniers.github.io/>» Blog</option><option value=https://nickdesaulniers.github.io/publications/>» Publications</option><option value=https://nickdesaulniers.github.io/talks/>» Talks</option></select></fieldset><ul class=main-navigation><li><a href=https://nickdesaulniers.github.io/about/ title=About rel="noopener noreferrer">About</a></li><li><a href=https://nickdesaulniers.github.io/blog/archives/ title=Archives rel="noopener noreferrer">Archives</a></li><li><a href=https://nickdesaulniers.github.io/ title=Blog>Blog</a></li><li><a href=https://nickdesaulniers.github.io/publications/ title=Publications rel="noopener noreferrer">Publications</a></li><li><a href=https://nickdesaulniers.github.io/talks/ title=Talks rel="noopener noreferrer">Talks</a></li></ul><ul class=subscription><a href=https://nickdesaulniers.github.io/index.xml target=_blank type=application/rss+xml title=RSS rel="noopener noreferrer"><i class="fa fa-rss-square fa-lg"></i></a></ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer"><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:https://nickdesaulniers.github.io/></fieldset></form></nav><div id=main><div id=content><div><article class=hentry role=article><header><p class=meta>Jan 20, 2023
- 8 minute read
- <a href=https://nickdesaulniers.github.io/blog/2023/01/20/debugging-wframe-larger-than/#disqus_thread>Comments</a>
- <a class=label href=https://nickdesaulniers.github.io/categories/debugging/>debugging</a></p><h1 class=entry-title>Debugging -Wframe-larger-than=</h1></header><div class=entry-content><p>Unless work is done per architecture to implement
<a href=https://docs.kernel.org/mm/vmalloced-kernel-stacks.html target=_blank rel=noopener>HAVE_ARCH_VMAP_STACK</a>
/ <code>CONFIG_VMAP_STACK</code>,
the Linux kernel
<a href=https://docs.kernel.org/x86/kernel-stacks.html target=_blank rel=noopener>defaults to two pages worth of stack per thread</a>.</p><hr><p>Note: on many contemporary systems the page size is 4KiB, but this is actually
configurable for many architectures. The trade offs probably require a separate
post. If you see code that checks for alignment via bitwise tricks like <code>addr &
4095 == 0</code> without checking <code>sysconf(_SC_PAGESIZE)</code> it is perhaps a red flag
for code that might be to reused on different systems.</p><hr><p>As a first line of defense against overflowing a thread&rsquo;s kernel stack, we
enable <code>-Wframe-larger-than=</code> with a value based on <code>CONFIG_FRAME_WARN</code>
(commonly <code>1024</code>). This doesn&rsquo;t guarantee we won&rsquo;t recurse enough at runtime to
overflow the stack. Defending against that is akin to solving the
<a href=https://en.wikipedia.org/wiki/Halting_problem target=_blank rel=noopener>Halting Problem</a>
unless you want to go to the extreme length of
<a href=https://rules.sonarsource.com/c/RSPEC-925 target=_blank rel=noopener>MISRA C&rsquo;s guidance</a>
that &ldquo;functions should not call themselves, either directly or indirectly.&rdquo;</p><p>It does help us
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/log/?qt=grep&q=-Wframe-larger-than" target=_blank rel=noopener>frequently</a>
find large structs that were stack allocated and probably should have been heap
(or sometimes statically) allocated. But the ergonomics of this warning have
room for improvement.</p><p>Let&rsquo;s say one day the build is failing because someone has introduced a new
instance of <code>-Wframe-larger-than=</code>. In the logs you see:</p><pre tabindex=0><code>&lt;source&gt;:8:6: warning: stack frame size (4104) exceeds limit (1024) in &#39;foo&#39; [-Wframe-larger-than]
void foo (void) {
     ^
</code></pre><p>So you go and look at source and see:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#dc322f>void</span> <span style=color:#268bd2>foo</span> (<span style=color:#dc322f>void</span>) {
</span></span><span style=display:flex><span>    <span style=color:#268bd2>bar</span>();
</span></span><span style=display:flex><span>    <span style=color:#268bd2>baz</span>();
</span></span><span style=display:flex><span>    <span style=color:#268bd2>quux</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>See any large local variables there? Thus begins the goose chase to understand
what inlining decisions led to <code>foo</code> having a large stack frame. Or how about
this?</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#dc322f>void</span> <span style=color:#268bd2>baz</span> (<span style=color:#dc322f>void</span>) {
</span></span><span style=display:flex><span>    <span style=color:#719e07>struct</span> widget;
</span></span><span style=display:flex><span>    ...
</span></span></code></pre></div><p>is a <code>struct widget</code> too large to be putting on the stack? Let&rsquo;s look at the
definition:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>struct</span> widget {
</span></span><span style=display:flex><span>    <span style=color:#719e07>struct</span> gadget gadget;
</span></span><span style=display:flex><span>    <span style=color:#719e07>struct</span> trombone trombone;
</span></span><span style=display:flex><span>    <span style=color:#dc322f>long</span> data [<span style=color:#2aa198>42</span>];
</span></span><span style=display:flex><span>    ...
</span></span></code></pre></div><p>What&rsquo;s the <code>sizeof</code> <code>struct widget</code>? Can you do that calculation in your head
quickly? What if the definitions of those structs are in other headers? More
goose chasing and perhaps an argument in favor of an IDE.</p><p><a href=https://dwarfstd.org/ target=_blank rel=noopener>DWARF</a> has this information (if/when
it&rsquo;s produced) but we don&rsquo;t have really great ways to visualize this
information. DWARF is a Jack of All Trades, it&rsquo;s good at many things, but kind
of great at none and so gets easily dunked on leading to distinct
<a href=https://blogs.oracle.com/linux/post/unwinding-stack-frame-pointers-and-orc target=_blank rel=noopener>unwind formats</a>
and
<a href=https://docs.kernel.org/bpf/btf.html target=_blank rel=noopener>type formats</a> being used in the kernel.</p><p>While commiserating about this conundrum with my colleague,
<a href=https://github.com/ilovepi target=_blank rel=noopener>Paul Kirth</a>, I mentioned that I really wished
there was tooling that would &ldquo;<strong>just break out the crayons and draw me a picture
of the stack</strong> [usage of a given function].&rdquo; Well, Paul must have been more upset
than I was, because he implemented some really nice optimization remarks to
help.</p><p>Starting with clang-16, you should be able to use
<code>-Rpass-analysis=stack-frame-layout</code> to get a drawing of your stack layout.</p><p>Let&rsquo;s see if we can better debug an instance of <code>-Wframe-larger-than=</code>
affecting the Linux kernel. Looking at
<a href=https://github.com/ClangBuiltLinux/continuous-integration2/actions/runs/3967665297/jobs/6803182658#step:5:210 target=_blank rel=noopener>logs from the CI from last night</a>,
I see a case:</p><pre tabindex=0><code>Warning: /builds/linux/fs/jffs2/xattr.c:775:6: warning: stack frame size (1216) exceeds limit (1024) in &#39;jffs2_build_xattr_subsystem&#39; [-Wframe-larger-than]
void jffs2_build_xattr_subsystem(struct jffs2_sb_info *c)
     ^
</code></pre><p>Looks like I can reproduce this locally:</p><pre tabindex=0><code>$ wget https://src.fedoraproject.org/rpms/kernel/raw/rawhide/f/kernel-aarch64-fedora.config -O .config
$ make -s LLVM=1 ARCH=arm64 -j128 olddefconfig fs/jffs2/xattr.o
fs/jffs2/xattr.c:775:6: warning: stack frame size (1216) exceeds limit (1024) in &#39;jffs2_build_xattr_subsystem&#39; [-Wframe-larger-than]
void jffs2_build_xattr_subsystem(struct jffs2_sb_info *c)
     ^
119/1216 (9.79%) spills, 1097/1216 (90.21%) variables
1 warning generated.
</code></pre><p>Paul also
<a href=https://reviews.llvm.org/rG2e1e2f52f357768186ecfcc5ac53d5fa53d1b094 target=_blank rel=noopener>recently added that tidbit</a>
(that was cutoff from CI logs) about the relative number of spills vs
variables. That can help you quickly get a sense how many stack slots are
variables&rsquo; storage vs spills from excessive register pressure (too many live
values).</p><p>If we simply add <code>-Rpass-analysis=stack-frame-layout</code>, we&rsquo;re going to get a
beautiful ASCII table for every function in a given TU. We can use the flag
<code>-mllvm -fiter-print-funcs=</code> to reduce the number of optimization remarks
emitted. For the kernel, that might look like:</p><pre tabindex=0><code>make -s LLVM=1 ARCH=arm64 -j128 fs/jffs2/xattr.o KCFLAGS=&#34;-Rpass-analysis=stack-frame-layout -mllvm -filter-print-funcs=jffs2_build_xattr_subsystem&#34; 
fs/jffs2/xattr.c:775:6: warning: stack frame size (1216) exceeds limit (1024) in &#39;jffs2_build_xattr_subsystem&#39; [-Wframe-larger-than]
void jffs2_build_xattr_subsystem(struct jffs2_sb_info *c)
     ^
119/1216 (9.79%) spills, 1097/1216 (90.21%) variables
fs/jffs2/xattr.c:776:1: remark: 
Function: jffs2_build_xattr_subsystem
Offset: [SP-8], Type: Spill, Align: 8, Size: 8
Offset: [SP-16], Type: Spill, Align: 8, Size: 8
Offset: [SP-24], Type: Spill, Align: 8, Size: 8
Offset: [SP-32], Type: Spill, Align: 8, Size: 8
Offset: [SP-40], Type: Spill, Align: 8, Size: 8
Offset: [SP-48], Type: Spill, Align: 8, Size: 8
Offset: [SP-56], Type: Spill, Align: 8, Size: 8
Offset: [SP-64], Type: Spill, Align: 8, Size: 8
Offset: [SP-72], Type: Spill, Align: 8, Size: 8
Offset: [SP-80], Type: Spill, Align: 8, Size: 8
Offset: [SP-88], Type: Spill, Align: 8, Size: 8
Offset: [SP-96], Type: Spill, Align: 8, Size: 8
Offset: [SP-104], Type: Variable, Align: 8, Size: 8
Offset: [SP-136], Type: Variable, Align: 8, Size: 28
    rr @ fs/jffs2/xattr.c:448
Offset: [SP-144], Type: Variable, Align: 8, Size: 8
Offset: [SP-1168], Type: Variable, Align: 8, Size: 1024
    xref_tmphash @ fs/jffs2/xattr.c:778
Offset: [SP-1176], Type: Spill, Align: 8, Size: 8
Offset: [SP-1180], Type: Spill, Align: 4, Size: 4
Offset: [SP-1192], Type: Spill, Align: 8, Size: 8
Offset: [SP-1196], Type: Spill, Align: 4, Size: 4 [-Rpass-analysis=stack-frame-layout]
{
^
1 warning generated.
</code></pre><p>(This kernel config had debug info enabled. Without this, lines above printing
variable and line number for <code>rr</code> and <code>xref_tmphash</code> would be omitted).</p><p>Spills can be occupied by different variables at different points for the
program counter (this is how DWARF encodes <code>DW_AT_location</code>). Not sure about
the Variable slots at Offsets <code>[SP-104]</code> and <code>[SP-144]</code> yet, maybe there&rsquo;s more
to fix in this nascent analysis, but the sizes show those aren&rsquo;t the droids&mldr;
err&mldr; stack slots that I&rsquo;m looking for.</p><p>So right off the bat, if I&rsquo;m setting <code>-Wframe-larger-than=1024</code> and
<code>xref_tmphash</code> is 1024B, that&rsquo;s a problem. <code>fs/jffs2/xattr.c:778</code>
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/jffs2/xattr.c?id=edc00350d205d2de8871b514c8f9b403d588e5d1#n778" target=_blank rel=noopener>corresponds to this statement</a>.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>#define XREF_TMPHASH_SIZE	(128)
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>...
</span></span><span style=display:flex><span><span style=color:#719e07>struct</span> jffs2_xattr_ref <span style=color:#719e07>*</span>xref_tmphash[XREF_TMPHASH_SIZE];
</span></span></code></pre></div><p>It doesn&rsquo;t matter what the <code>sizeof</code> <code>struct jffs2_xattr_ref</code> since
<code>xref_tmphash</code> is a 128 element array of pointers to such struct. 128 times 8
(pointers are 64b on the kernel&rsquo;s aarch64 target) is 1024.</p><p>Let&rsquo;s see if anyone has tried to fix this. Yep, looking at
<a href="https://lore.kernel.org/lkml/?q=jffs2_build_xattr_subsystem" target=_blank rel=noopener>lore</a> I see:</p><ul><li><a href=https://lore.kernel.org/lkml/1452193868-15816-1-git-send-email-tim.gardner@canonical.com/ target=_blank rel=noopener>fix sent in 2016</a><ul><li><a href=https://lore.kernel.org/lkml/1454338130.133285.305.camel@infradead.org/ target=_blank rel=noopener>rejected</a></li></ul></li><li><a href=https://lore.kernel.org/lkml/20170509203003.11986-1-fabf@skynet.be/ target=_blank rel=noopener>another fix sent in 2017</a> (looks like it never received feedback)</li><li><a href=https://lore.kernel.org/lkml/YTbOs13waorzamZ6@Ryzen-9-3900X.localdomain/ target=_blank rel=noopener>report from my co-maintainer</a>
<a href=https://nathanchance.dev/ target=_blank rel=noopener>Nathan</a> in 2021</li><li>report from
<a href=https://lore.kernel.org/lkml/202110250146.2w7fdWCN-lkp@intel.com/ target=_blank rel=noopener>bot</a> in 2021</li><li><a href=https://lore.kernel.org/lkml/78cae1c8-9a2b-b0a4-d9a1-efeb03290f58@w6rz.net/ target=_blank rel=noopener>report to stable last year</a></li></ul><p>The patch from 2017 LGTM, and perhaps has fallen through the cracks and just
needs to be pinged/reviewed,
<a href=https://lore.kernel.org/lkml/Y8sN9+0BvZfsEq1v@google.com/ target=_blank rel=noopener>which I&rsquo;ve done</a>.
Hopefully it can get picked up.</p><p><code>-Wframe-larger-than=</code> issues in the Linux kernel are numerous (at least with
clang builds for now). They can be a bit of work to track down. One of
<a href=https://github.com/ClangBuiltLinux/linux/issues/39 target=_blank rel=noopener>our oldest open issues</a>
still on the TODO list to fix is <code>-fsanitize=kernel-address</code> (via
<code>CONFIG_KASAN=y</code>) leading to excessive stack usage (at least when compared to
<code>-fsanitize=address</code> aka ASAN). Another
<a href=https://github.com/llvm/llvm-project/issues/41896 target=_blank rel=noopener>TODO</a>
seems to be related to passing structs by value. My hope is these optimization
remarks will help us differentiate between compiler bugs vs kernel source bugs
quicker.</p><p>Whether or not an optimization remark is the most ergonomic tooling is
hopefully still up for debate, though the current implementation was an
iteration based on compromise. Requiring debug info for better diagnostics
trades compile time in clang, which is also unfortunate.</p><p>For now though, I&rsquo;m happy to celebrate improved tooling
in this regard. Cheers
<a href=https://github.com/ilovepi target=_blank rel=noopener>Paul</a>!</p><p>That&rsquo;s pretty much the end of the post. Some other tools I&rsquo;ve used in this
area if you&rsquo;re still interested:</p><hr><p><code>llvm-dwarfdump</code> or GNU <code>objdump --dwarf=info</code> can print the DWARF stream. I
had written
<a href=https://github.com/ClangBuiltLinux/frame-larger-than target=_blank rel=noopener>a python script</a>
to attempt to decode this information. It&rsquo;s manually tested, incomplete, and
quite buggy. The library I depend on for decoding DWARF and ELF doesn&rsquo;t support
all of the architectures the Linux kernel does, which has led to issues being
unable to debug these warnings for specific architectures. A tool failure when
things are actively on fire is stressful.</p><pre tabindex=0><code>$ frame_larger_than.py arch/x86/kernel/kvm.o kvm_send_ipi_mask_allbutself
kvm_send_ipi_mask_allbutself:
        1024    struct cpumask          new_mask
        4       unsigned int            this_cpu
        8       const struct cpumask*   local_mask
        4       int                     pscr_ret__
        4       int                     pfo_ret__
cpumask_copy:
bitmap_copy:
        4       unsigned int            len
        4       unsigned int            len
cpumask_clear_cpu:
clear_bit:
arch_clear_bit:
</code></pre><hr><p>&ldquo;Poke-a-hole&rdquo; aka <code>pahole</code> can print the size of structs. Check out the
<a href=https://lwn.net/Articles/335942/ target=_blank rel=noopener>LWN
article</a>.</p><pre tabindex=0><code># Make sure you&#39;ve built with debug info enabled!
$ pahole fs/jffs2/xattr.o
...
struct jffs2_xattr_ref {
        void *                     always_null;          /*     0     8 */
        struct jffs2_raw_node_ref * node;                /*     8     8 */
        uint8_t                    class;                /*    16     1 */
        uint8_t                    flags;                /*    17     1 */
        u16                        unused;               /*    18     2 */
        uint32_t                   xseqno;               /*    20     4 */
        union {
                struct jffs2_inode_cache * ic;           /*    24     8 */
                uint32_t           ino;                  /*    24     4 */
        };                                               /*    24     8 */
        union {
                struct jffs2_inode_cache * ic;                   /*     0     8 */
                uint32_t                   ino;                  /*     0     4 */
        };

        union {
                struct jffs2_xattr_datum * xd;           /*    32     8 */
                uint32_t           xid;                  /*    32     4 */
        };                                               /*    32     8 */
        union {
                struct jffs2_xattr_datum * xd;                   /*     0     8 */
                uint32_t                   xid;                  /*     0     4 */
        };

        struct jffs2_xattr_ref *   next;                 /*    40     8 */

        /* size: 48, cachelines: 1, members: 9 */
        /* last cacheline: 48 bytes */
};
</code></pre><hr><p>The kernel has a script (<code>scripts/stackusage</code>) that can print the estimated stack usage of each function in <code>vmlinux</code> to a file. Example:</p><pre tabindex=0><code>$ ./scripts/stackusage LLVM=1 -j128 defconfig all
...
./scripts/stackusage: output written to /tmp/stackusage.3991505.3gRw
$ cat /tmp/stackusage.3991505.3gRw
arch/x86/entry/common.c:119:do_int80_syscall_32	24	dynamic
arch/x86/entry/common.c:138:__do_fast_syscall_32	40	dynamic
arch/x86/entry/common.c:186:do_fast_syscall_32	16	static
arch/x86/entry/common.c:238:do_SYSENTER_32	0	static
...
</code></pre><hr><p>Finally, GCC currently supports (but clang currently does not)
<code>-fconserve-stack</code>. From playing with it, it seems that this flag causes GCC to
limit inlining if would increase the stack usage of a caller beyond what
appears to be through experimentation an arch specific threshold.</p><p>Clang
<a href=https://github.com/llvm/llvm-project/commit/8564e2fea559c58fecab3c7c01acf498bbe7820a target=_blank rel=noopener>recently</a> got <code>-finline-max-stacksize=</code>, which feels like a nuclear option to
me. We haven&rsquo;t deployed it yet in the kernel, but it might ultimately be
necessary to use. We&rsquo;ll see. I would hate to potentially cover up other issues
that should perhaps be fixed first.</p></div><footer><p class=meta><span class="byline author vcard">Posted by <span class=fn>Nick Desaulniers</span></span>
<time>Jan 20, 2023</time></span></p><p class=meta><a class="basic-alignment left" href=https://nickdesaulniers.github.io/blog/2020/04/06/off-by-two/ title="Off by Two">Off by Two</a></p><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//wangstabill.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></div><aside class="sidebar thirds"><section class="first odd"><p></p></section><ul class=sidebar-nav><li class=sidebar-nav-item><a target=_blank rel="noopener noreferrer" href=https://github.com/nickdesaulniers title=https://github.com/nickdesaulniers><i class="fa fa-github fa-3x"></i></a>
<a target=_blank rel="me noopener noreferrer" href=https://fosstodon.org/@llvm title=https://fosstodon.org/@llvm><i class="fa fa-mastodon fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href=https://www.linkedin.com/in/nick-desaulniers-75520334 title=https://www.linkedin.com/in/nick-desaulniers-75520334><i class="fa fa-linkedin fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href=https://www.youtube.com/channel/UC68vgKSuS1Xjg9wpdvShfSQ title=https://www.youtube.com/channel/UC68vgKSuS1Xjg9wpdvShfSQ><i class="fa fa-youtube fa-3x"></i></a></li></ul><section class=even><h1>Recent Posts</h1><ul id=recent_posts><li class=post><a href=/blog/2023/01/20/debugging-wframe-larger-than/>Debugging -Wframe-larger-than=</a></li><li class=post><a href=/blog/2020/04/06/off-by-two/>Off by Two</a></li><li class=post><a href=/blog/2019/05/12/f-vs-f-void-in-c-vs-c-plus-plus/>f() vs f(void) in C vs C++</a></li><li class=post><a href=/blog/2019/01/18/finding-compiler-bugs-with-c-reduce/>Finding Compiler Bugs With C-Reduce</a></li></ul></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2023 Nick Desaulniers - <a href=https://nickdesaulniers.github.io/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.</p></footer><script>var _gaq=[["_setAccount","UA-36993986-1"],["_trackPageview"]];(function(e,t){var n=e.createElement(t),s=e.getElementsByTagName(t)[0];n.src=("https:"==location.protocol?"//ssl":"//www")+".google-analytics.com/ga.js",s.parentNode.insertBefore(n,s)})(document,"script")</script></body></html>