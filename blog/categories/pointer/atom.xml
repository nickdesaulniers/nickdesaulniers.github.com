<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Pointer | Nick Desaulniers]]></title>
  <link href="http://nickdesaulniers.github.io/blog/categories/pointer/atom.xml" rel="self"/>
  <link href="http://nickdesaulniers.github.io/"/>
  <updated>2020-04-06T08:08:18-07:00</updated>
  <id>http://nickdesaulniers.github.io/</id>
  <author>
    <name><![CDATA[Nick Desaulniers]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Data Models and Word Size]]></title>
    <link href="http://nickdesaulniers.github.io/blog/2016/05/30/data-models-and-word-size/"/>
    <updated>2016-05-30T12:54:00-07:00</updated>
    <id>http://nickdesaulniers.github.io/blog/2016/05/30/data-models-and-word-size</id>
    <content type="html"><![CDATA[<p><em>This post is a follow up to
<a href="/blog/2016/05/15/whats-in-a-word/">my previous blog post about word size</a>.</em></p>

<p>Three C/C++ programmers walk into a bar.  One argues that sizeof(void*) is
equivalent to sizeof(long), one argues that sizeof(void*) is equivalent to
sizeof(int), and the third argues it’s sizeof(long long).  Simultaneously,
they’re all right, but they’re also all wrong (and need a lesson about portable
C code).  What the hell is going on?</p>

<p>One of the first few programs a programmer might write after hello world is
something like this:</p>

<p>```c</p>

<h1>include &lt;stdio.h></h1>

<p>int main () {
  printf(&ldquo;sizeof(int): %zu\n&rdquo;, sizeof(int));
  printf(&ldquo;sizeof(long): %zu\n&rdquo;, sizeof(long));
  printf(&ldquo;sizeof(long long): %zu\n&rdquo;, sizeof(long long));
  printf(&ldquo;sizeof(void<em>): %zu\n&rdquo;, sizeof(void</em>));
}
```</p>

<p><em>Note the use of the %zu format specifier, a C99 addition that isn’t portable to
older compilers!  (This post is more about considerations when porting older
code to newer machines, not about porting newer code to run on older machines.
Not having a standards compliant C compiler makes writing more portable C code
even trickier, and is a subject for another blog post).</em></p>

<p>When I run that code on my x86-64 OSX machine, I get the following output:</p>

<p><code>sh
sizeof(int): 4
sizeof(long): 8
sizeof(long long): 8
sizeof(void*): 8
</code></p>

<p>So it looks like I would be the first programmer in the story in the first
paragraph, since on my machine, it looks like sizeof(long) == sizeof(void*).
Also note how sizeof(long long) is equivalent as well.</p>

<p>But what would happen if I compiled my code on a 32 bit machine?  Luckily, my
processor has backwards compatibility with 32b binaries, so I can cross compile
it locally and still run it. Ex:</p>

<p><code>sh
➜  clang sizeof.c -Wall -Wextra -Wpedantic
➜  file a.out
a.out: Mach-O 64-bit executable x86_64
➜  clang sizeof.c -Wall -Wextra -Wpedantic -m32
➜  file a.out
a.out: Mach-O executable i386
➜  ./a.out
sizeof(int): 4
sizeof(long): 4
sizeof(long long): 8
sizeof(void*): 4
</code></p>

<p>Huh, suddenly sizeof(void*) == sizeof(int) == sizeof(long)!  This seems
to be the case of the second programmer from the story.</p>

<p>Both programmer 1 and programmer 2 might agree that the size of a pointer is
equivalent to their machine’s respective
<a href="/blog/2016/05/15/whats-in-a-word/">word size</a>,
but that too would be an incorrect assumption for portable C/C++ code!</p>

<p>Programmer 3 goes through the hellscape that is installing a working compiler
for Windows and building a 64b command line application (to be fair, installing
command line tools for OSX is worse; installing a compiler for most OS’ leaves
much to be desired).  When they run that program, they see:</p>

<p><code>
sizeof(int): 4
sizeof(long): 4
sizeof(long long): 8
sizeof(void*): 8
</code></p>

<p>This is yet a third case (the third programmer from the story).  In this case,
only sizeof(long long) is equivalent to sizeof(void*).</p>

<h3>Data Models</h3>

<p>What these programmers are seeing is known as data models.  Programmer 1 one on
a 64b x86-64 OSX machine had an LP64 data model where longs (L), (larger long
longs,) and pointers (P) are 64b, but ints were 32b.  Programmer 2 on a 32b x86
OSX machine had an ILP32 data model where ints (I), longs (L), and pointers (P)
were 32b, but long longs were 64b.  Programmer 3 on a 64b x86-64 Windows
machine had a LLP64 data model, where only long longs (LL) and pointers (P)
were 64b, ints and longs being 32b.</p>

<table>
<thead>
<tr>
<th><strong>Data model</strong> </th>
<th> <strong>sizeof(int)</strong> </th>
<th> <strong>sizeof(long)</strong> </th>
<th> <strong>sizeof(long long)</strong> </th>
<th> <strong>sizeof(void*)</strong> </th>
<th> <strong>example</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>ILP32 </td>
<td> 32b </td>
<td> 32b </td>
<td> 64b </td>
<td> 32b </td>
<td> Win32, i386 OSX &amp; Linux</td>
</tr>
<tr>
<td>LP64 </td>
<td> 32b </td>
<td> 64b </td>
<td> 64b </td>
<td> 64b </td>
<td> x86-64 OSX &amp; Linux</td>
</tr>
<tr>
<td>LLP64 </td>
<td> 32b </td>
<td> 32b </td>
<td> 64b </td>
<td> 64b </td>
<td> Win64</td>
</tr>
</tbody>
</table>


<p>There are older data models such as LP32 (Windows 3.1, Macintosh, where ints
are 16b), and more exotic ones like ILP64, and SILP64.  Knowing the data model
thus is important for portable C/C++ code.</p>

<h3>Historical Perspective</h3>

<p>Running out of address space is and will continue to be tradition in computing.
Applications become bigger as computer power and memory gets cheaper.
Companies want to sell chips that have larger word sizes to address more
memory, but early adopters don’t want to buy a computer where there favorite
application hasn’t been compiled and thus doesn’t exist on yet.  <strong>Someone from
the back shouts <em>virtual machines</em> then ducks as a chair is thrown.</strong></p>

<p><a href="http://www.unix.org/version2/whatsnew/lp64_wp.html">This document</a>
highlights some reasons why LP64 is preferred to ILP64: ILP64
made portable C code that only needed 32b of precision harder to maintain (on
ILP64 an int was 64b, but a short was 16b!).  It mentions how for data
structures that did not contain pointers, their size would be the same on LLP64
as ILP32, which is the direction Microsoft went.  LLP64 was essentially the
ILP32 model with 64b pointers.</p>

<p><em>Linux also supports an ABI called
<a href="https://en.wikipedia.org/wiki/X32_ABI">x32</a>
which can use x86-64 ISA improvements but uses 32b pointers to reduce the size
of data structures that would otherwise have 64b pointers.</em></p>

<p>For a great historical perspective on the evolution of word size and data
models, as well as the &ldquo;toil and trouble&rdquo; caused,
<a href="https://queue.acm.org/detail.cfm?id=1165766">this paper</a>
was an excellent reference.  It describes Microsoft finally abandoning support
for 16b data models in Windows XP 64.  It mentions that the industry was pretty
split between LP64, LLP64, and ILP64 as porting code from the good old days of
ILP32 would break in different ways.  That the use of long was more prevalent
in Windows applications vs the use of int in unix applications.  It also makes
the key point that a lot of programmers from the ILP32 era made assumptions
that sizeof(int) == sizeof(long) == sizeof(void*) which would not hold true
for the LP64/LLP64 era.</p>

<p>One important point the paper makes makes that’s easily missed is that typedef
wasn’t added to C until 1977 when hardware manufactures still couldn’t agree on
how many bits were in a char (CHAR_BITS) and some machines were using 24b
addressing schemes.  stdint.h and inttypes.h did not exist yet.</p>

<p><a href="/blog/2016/05/15/whats-in-a-word/">This article</a>
talks about two main categories of effects of switching from ILP32 to LP64 and
has excellent examples of problematic code.  That section near the end is worth
the read alone and makes excellent points to look for during code review.</p>

<h3>Conclusion</h3>

<p>Word size or ISA doesn’t tell you anything about sizeof(int), sizeof(long), or
sizeof(long long).  We also saw that one machine can support multiple different
data models (when I compiled and ran the same code with the -m32 flag).</p>

<p>The C standard tells you minimum guaranteed sizes for these types, but the data
model (part of the ABI, external to but abiding by the C standard) is what
tells you about the specifics sizes of standard integers and pointers.</p>

<h3>Further Reading</h3>

<ul>
<li><a href="http://www.unix.org/version2/whatsnew/lp64_wp.html">64-Bit Programming Models: Why LP64?</a></li>
<li><a href="https://queue.acm.org/detail.cfm?id=1165766">The Long Road to 64 Bits</a></li>
<li><a href="http://www.unix.org/whitepapers/64bit.html">The UNIX System &mdash; 64bit and Data Size Neutrality</a></li>
<li><a href="https://en.wikipedia.org/wiki/64-bit_computing#64-bit_data_models">64-bit data models</a></li>
<li><a href="https://docs.oracle.com/cd/E19620-01/805-3024/lp64-1/index.html">C Language Data Type Models: LP64 and ILP32</a></li>
<li><a href="https://blogs.oracle.com/nike/entry/ilp64_lp64_llp64">ILP64, LP64, LLP64</a></li>
<li><a href="https://en.wikipedia.org/wiki/X32_ABI">x32 ABI</a></li>
<li><a href="http://stackoverflow.com/a/9162072">difference between stdint.h and inttypes.h</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa384083%28v=vs.85%29.aspx">Abstract Data Models</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa384264%28v=vs.85%29.aspx">The New Data Types</a></li>
<li><a href="http://stackoverflow.com/a/13413892">Is there any reason not to use fixed width integer types (e.g. uint8_t)?</a></li>
<li><a href="https://blogs.msdn.microsoft.com/oldnewthing/20050131-00/?p=36563/">Why did the Win64 team choose the LLP64 model?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C Function Pointers Alternate Syntax]]></title>
    <link href="http://nickdesaulniers.github.io/blog/2013/01/26/c-function-pointers-alternate-syntax/"/>
    <updated>2013-01-26T17:49:00-08:00</updated>
    <id>http://nickdesaulniers.github.io/blog/2013/01/26/c-function-pointers-alternate-syntax</id>
    <content type="html"><![CDATA[<p>On an interview with <a href="https://squareup.com/">Square</a>, I made the mistake
of stating that one of the benefits of working with JavaScript over C is
that functions are <a href="http://en.wikipedia.org/wiki/First-class_function">first class</a>
in JavaScript, therefore they may be <a href="http://eloquentjavascript.net/chapter6.html">passed around</a>.  To which the
interviewer replied, &ldquo;Well, C can do that, what about function pointers?&rdquo;  What? Luckily, I
was able to get out of that jam by guessing that JavaScript had a nicer
syntax.</p>

<p>While I was taught some C in university, we had never gone over function
pointers or more in depth topics such as <a href="http://en.wikipedia.org/wiki/Static_library">static</a>
or <a href="http://en.wikipedia.org/wiki/Dynamic_library">dynamic</a> <a href="http://www.yolinux.com/TUTORIALS/LibraryArchives-StaticAndDynamic.html">linkage</a>.
I was so embarrassed that my expensive (read <a href="http://online.wsj.com/article/SB10001424127887324442304578231922159602676.html?mod=WSJ_hps_LEFTTopStories">overpriced</a>)
degree had not taught me more about
the C programming language, especially from the Computer Engineering
department that focuses on software <strong>AND</strong> hardware.  On my exit
interview with the dean, I was very opinionated on the amount of C that
was (or wasn&rsquo;t) taught at my university.  His argument was that there
are only so much of so many languages you can cover in a university, which
to some extent is valid.  My problem has been that I&rsquo;ve enjoyed learning
many different programming languages, though I didn&rsquo;t really get it the
first time around (with Java).  I think knowing many different languages
and their respective paradigms makes you a better programmer in other
languages, since you can bring a <a href="http://therubyway.org/">Ruby Way</a> to
<a href="http://www.rust-lang.org/">Rust</a> or a <a href="http://www.ibm.com/developerworks/library/wa-javascript/index.html">JavaScript functional</a>
<a href="http://interglacial.com/hoj/hoj.html">style</a> into C.</p>

<p>I had read two books in the meantime that really flushed out more of the
C language to me and I would definitely recommend them to those who want
to learn more about the language. They are <a href="http://shop.oreilly.com/product/0636920015482.do">Head First C</a> by Dave and Dawn
Griffiths and <a href="http://shop.oreilly.com/product/0636920025108.do">21st Century C</a> by Ben Klemens.
I&rsquo;m also aware that <a href="http://en.wikipedia.org/wiki/The_C_Programming_Language">The C Programming Language</a> by
Brian Kernighan and Dennis Ritchie is also known as the canonical text.
The book is often referred to as &lsquo;K&amp;R&rsquo; after the authors' initials, and Dennis
Ritchie was the original creators of the C language and co-developer of
Unix.  I&rsquo;d love to get a chance to read it someday.</p>

<p><a href="http://blog.charlescary.com/?p=95">This article</a> appeared on
<a href="http://news.ycombinator.com/">Hacker News</a> and really piqued my
interest.  Defenitely a great read.  What really stuck out to me was one
of the <a href="http://blog.charlescary.com/?p=95#comment-31">comments</a> though.
The author of the comment mentioned a less ugly syntax for function
pointers, with a <a href="http://pastebin.com/MsJLY22j">link to an example</a>.
Now I&rsquo;m not sure what the commenter meant by &ldquo;these params decay
naturally to function pointers&rdquo; but I was skeptical about this different
syntax.  Even the <a href="http://en.wikipedia.org/wiki/Function_pointer#Example_in_C">Wikipedia article</a>
used the syntax that I was familiar with.  So I wrote up a quick example
to try it:</p>

<p>```c
// compiled with:
// clang -Wall -Wextra function_pointers.c -o function_pointers</p>

<h1>include &ldquo;stdio.h&rdquo;</h1>

<p>void usual_syntax (void (*fn) (int x)) {
  puts(&ldquo;usual syntax start&rdquo;);
  fn(1);
  puts(&ldquo;usual syntax end&rdquo;);
}</p>

<p>void other_syntax (void fn (int x)) {
  puts(&ldquo;other syntax start&rdquo;);
  fn(2);
  puts(&ldquo;other syntax end&rdquo;);
}</p>

<p>void hello (int x) {
  printf(&ldquo;hello %d\n&rdquo;, x);
}</p>

<p>int main () {
  puts(&ldquo;hello world&rdquo;);
  usual_syntax(hello);
  other_syntax(hello);
}
```</p>

<p>Sure enough we get:</p>

<p><code>
hello world
usual syntax start
hello 1
usual syntax end
other syntax start
hello 2
other syntax end
</code></p>

<p>So the moral to the story I guess is that there&rsquo;s always more to your
favorite language.  From using <a href="https://github.com/nickdesaulniers/21stCenturyC/blob/master/chpt10/variadic_macros.c">variadic macros</a>
with <a href="https://github.com/nickdesaulniers/21stCenturyC/blob/master/chpt10/compound_literal.c">compound literals</a>
to enable a more <a href="https://github.com/nickdesaulniers/21stCenturyC/blob/master/chpt10/foreach.c">functional style</a>
in C to reflecting upon a function&rsquo;s <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/length">number of arguments</a>
or <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/name">name</a>
or <a href="http://taylodl.wordpress.com/2012/09/03/functional-javascript-memoization-part-ii/">adding attributes to a function</a>
or the
<a href="http://matt.might.net/articles/implementation-of-recursive-fixed-point-y-combinator-in-javascript-for-memoization/">y-combinator</a>
in JavaScript, I learn something new every day.  And I hope that you did
too!  Thanks for reading!  If you have some other recommendations on
good programming books, or design patterns, please leave a comment or
write a reply blog post!</p>
]]></content>
  </entry>
  
</feed>
