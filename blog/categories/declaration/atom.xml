<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: declaration | Nick Desaulniers]]></title>
  <link href="http://nickdesaulniers.github.io/blog/categories/declaration/atom.xml" rel="self"/>
  <link href="http://nickdesaulniers.github.io/"/>
  <updated>2020-04-06T08:08:18-07:00</updated>
  <id>http://nickdesaulniers.github.io/</id>
  <author>
    <name><![CDATA[Nick Desaulniers]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[f() vs f(void) in C vs C++]]></title>
    <link href="http://nickdesaulniers.github.io/blog/2019/05/12/f-vs-f-void-in-c-vs-c-plus-plus/"/>
    <updated>2019-05-12T13:42:00-07:00</updated>
    <id>http://nickdesaulniers.github.io/blog/2019/05/12/f-vs-f-void-in-c-vs-c-plus-plus</id>
    <content type="html"><![CDATA[<p>TL;DR</p>

<p>Prefer <code>f(void)</code> in C to <em>potentially</em> save a 2B instruction per function call
when targeting x86_64 as a micro-optimization. <code>-Wstrict-prototypes</code> can help.
Doesn’t matter for C++.</p>

<h2>The Problem</h2>

<p>While messing around with some C code in
<a href="http://godbolt.org">godbolt Compiler Explorer</a>,
I kept noticing a particular funny case.  It seemed with my small test cases
that sometimes function calls would zero out the return register before calling
a function that took no arguments, but other times not.  Upon closer
inspection, it seemed like a difference between function definitions,
particularly <code>f()</code> vs <code>f(void)</code>.  For example, the following C code:</p>

<p>```c
int foo();
int bar(void);</p>

<p>int baz() {
  foo();
  bar();
  return 0;
}
<code>
would generate the following assembly:
</code>gas
baz:
  pushq %rax # realign stack for callq
  xorl %eax, %eax # zero %al, non variadic
  callq foo
  callq bar # why you no zero %al?
  xorl %eax, %eax
  popq %rcx
  retq
<code>``
In particular, focus on the call the</code>foo<code>vs the call to</code>bar<code>. </code>foo<code>is
preceded with</code>xorl %eax, %eax<code>(X ^ X == 0, and is the shortest encoding for
an instruction that zeroes a register on the variable length encoded x86_64,
which is why its used a lot such as in setting the return value).  (If you’re
curious about the pushq/popq, see
[point #1](/blog/2014/04/18/lets-write-some-x86-64/).)
Now I’ve seen zeroing before (see
[point #3](/blog/2014/04/18/lets-write-some-x86-64/)
and remember that</code>%al<code>is the lowest byte of</code>%eax<code>and</code>%rax<code>), but if it was
done for the call to</code>foo<code>, then why was it not additionally done for the call
to</code>bar<code>?</code>%eax` being x86_64’s return register for the C ABI should be treated
as call clobbered.  So if you set it, then made a function call that may have
clobbered it (and you can’t deduce otherwise), then wouldn’t you have to reset
it to make an additional function call?</p>

<p>Let’s look at a few more cases and see if we can find the pattern.  Let’s take
a look at 2 sequential calls to <code>foo</code> vs 2 sequential calls to <code>bar</code>:
<code>c
int foo();
int quux() {
  foo(); // notice %eax is always zeroed
  foo(); // notice %eax is always zeroed
return 0;
}
</code>
<code>gas
quux:
  pushq %rax
  xorl %eax, %eax
  callq foo
  xorl %eax, %eax
  callq foo
  xorl %eax, %eax
  popq %rcx
  retq
</code>
<code>c
int bar(void);
int quuz() {
  bar(); // notice %eax is not zeroed
  bar(); // notice %eax is not zeroed
  return 0;
}
</code>
<code>gas
quuz:
  pushq %rax
  callq bar
  callq bar
  xorl %eax, %eax
  popq %rcx
  retq
</code></p>

<p>So it should be pretty clear now that the pattern is <code>f(void)</code> does not
generate the <code>xorl %eax, %eax</code>, while <code>f()</code> does.  What gives, aren’t they
declaring <code>f</code> the same; a function that takes no parameters?  Unfortunately, in
C the answer is no, and C and C++ differ here.</p>

<h2>An explanation</h2>

<p><code>f()</code> is not necessarily &ldquo;<code>f</code> takes no arguments&rdquo; but more of &ldquo;I’m not telling
you what arguments <code>f</code> takes (but it’s not variadic).&rdquo;  Consider this perfectly
legal C and C++ code:
<code>c
int foo();
int foo(int x) { return 42; }
</code>
It seems that C++ inherited this from C, but only in C++ does <code>f()</code> seems to
have the semantics of &ldquo;<code>f</code> takes no arguments,&rdquo; as the previous examples all no
longer have the <code>xorl %eax, %eax</code>.  Same for <code>f(void)</code> in C or C++. That&rsquo;s
because <code>foo()</code> and <code>foo(int)</code> are two different function in C++ thanks to
function overloading (thanks reddit user /u/OldWolf2). Also, it seems that C
supported this difference for backwards compatibility w/ K &amp; R C.</p>

<p><code>c
int bar(void);
int bar(int x) { return x + 42; }
</code>
Is an error in C, but in C++ thanks to function overloading these are two
separate functions! (<code>_Z3barv</code> vs <code>_Z3bari</code>). (Thanks HN user
<a href="https://news.ycombinator.com/item?id=19895079">pdpi</a>, for helping me
understand this. Cunningham&rsquo;s Law ftw.)</p>

<p>Needless to say, If you write code like that where your function declarations
and definitions do not match, you will be put in prison.
<a href="https://youtu.be/D2ydY5sBnIg?t=97">Do not pass go, do not collect $200</a>).
<a href="https://clang.llvm.org/docs/ControlFlowIntegrity.html">Control flow integrity</a>
analysis is particularly sensitive to these cases, manifesting in runtime
crashes.</p>

<h2>What could a sufficiently smart compiler do to help?</h2>

<p><code>-Wall</code> and <code>-Wextra</code> will just flag the <code>-Wunused-parameter</code>.  We need the
help of <code>-Wmissing-prototypes</code> to flag the mismatch between declaration and
definition. (An aside; I had a hard time remembering which was the declaration
and which was the definition when learning C++.  The mnemonic I came up with
and still use today is: think of definition as in muscle definition; where the
meat of the function is.  Declarations are just hot air.)  It’s not until we
get to <code>-Wstrict-prototypes</code> do we get a warning that we should use <code>f(void)</code>.
<code>-Wstrict-prototypes</code> is kind of a stylistic warning, so that’s why it’s not
part of <code>-Wall</code> or <code>-Wextra</code>.  Stylistic warnings are in bikeshed territory
(*cough* <code>-Wparentheses</code> *cough*).</p>

<p>One issue with C and C++’s style of code sharing and encapsulation via headers
is that declarations often aren’t enough for the powerful analysis techniques
of production optimizing compilers (whether or not a pointer
<a href="https://jonasdevlieghere.com/escape-analysis-capture-tracking-in-llvm/">&ldquo;escapes&rdquo;</a>
is a big one that comes to mind).  Let’s see if a &ldquo;sufficiently smart compiler&rdquo;
could notice when we’ve declared <code>f()</code>, but via observation of the definition
of <code>f()</code> noticed that we really only needed the semantics of <code>f(void)</code>.</p>

<p>```c
int puts(const char*);
int <strong>attribute</strong>((noinline)) foo2() {
  puts(&ldquo;hello&rdquo;);
  return 0;
}</p>

<p>int quacks() {
  foo2();
  foo2();
  return 0;
}
<code>
</code>gas
quacks:
  pushq %rax
  callq foo2
  callq foo2
  xorl %eax, %eax
  popq %rcx
  retq
```</p>

<p>A ha! So by having the full definition of <code>foo2</code> in this case in the same
translation unit, Clang was able to deduce that <code>foo2</code> didn’t actually need the
semantics of <code>f()</code>, so it could skip the <code>xorl %eax, %eax</code> we’d seen for <code>f()</code>
style definitions earlier.  If we change <code>foo2</code> to a declaration (such as would
be the case if it was defined in an <code>external</code> translation unit, and its
declaration included via header), then Clang can no longer observe whether
<code>foo2</code> definition differs or not from the declaration.</p>

<p>So Clang can potentially save you a single instruction (<code>xorl %eax, %eax</code>)
whose encoding is only 2B, per function call to functions declared in the style
<code>f()</code>, but only IF the definition is in the same translation unit and doesn’t
differ from the declaration, and you happen to be targeting x86_64. *deflated
whew* But usually it can’t because it’s only been provided the declaration via
header.</p>

<h2>Conclusion</h2>

<p>I certainly think <code>f()</code> is <em>prettier</em> than <code>f(void)</code> (so C++ got this right),
but pretty code may not always be the fastest and it’s not always
straightforward when to prefer one over the other.</p>

<p>So it seems that <code>f()</code> is ok for strictly C++ code.  For C or mixed C and C++,
<code>f(void)</code> might be better.</p>

<h2>References</h2>

<ul>
<li><a href="https://stackoverflow.com/q/6212665/1027966">https://stackoverflow.com/q/6212665/1027966</a></li>
<li><a href="https://stackoverflow.com/q/693788/1027966">https://stackoverflow.com/q/693788/1027966</a></li>
<li><a href="https://stackoverflow.com/q/12643202/1027966">https://stackoverflow.com/q/12643202/1027966</a></li>
<li><a href="https://stackoverflow.com/q/51032/1027966">https://stackoverflow.com/q/51032/1027966</a></li>
<li><a href="https://stackoverflow.com/q/416345/1027966">https://stackoverflow.com/q/416345/1027966</a></li>
<li><a href="https://stackoverflow.com/q/41803937/1027966">https://stackoverflow.com/q/41803937/1027966</a></li>
<li><a href="http://david.tribble.com/text/cdiffs.htm#C99-empty-parm">http://david.tribble.com/text/cdiffs.htm#C99-empty-parm</a></li>
<li><a href="https://godbolt.org/z/nsgGpt">https://godbolt.org/z/nsgGpt</a></li>
<li><a href="https://godbolt.org/z/IORbBb">https://godbolt.org/z/IORbBb</a></li>
<li><a href="https://godbolt.org/z/51s7K0">https://godbolt.org/z/51s7K0</a></li>
<li><a href="https://bugs.llvm.org/show_bug.cgi?id=41851">https://bugs.llvm.org/show_bug.cgi?id=41851</a> (the maintainer of Clang cites
the relevant part of the C11 spec for this)</li>
</ul>

]]></content>
  </entry>
  
</feed>
