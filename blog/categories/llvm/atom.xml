<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: llvm | Nick Desaulniers]]></title>
  <link href="http://nickdesaulniers.github.io/blog/categories/llvm/atom.xml" rel="self"/>
  <link href="http://nickdesaulniers.github.io/"/>
  <updated>2020-04-06T08:08:18-07:00</updated>
  <id>http://nickdesaulniers.github.io/</id>
  <author>
    <name><![CDATA[Nick Desaulniers]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Off by Two]]></title>
    <link href="http://nickdesaulniers.github.io/blog/2020/04/06/off-by-two/"/>
    <updated>2020-04-06T07:32:00-07:00</updated>
    <id>http://nickdesaulniers.github.io/blog/2020/04/06/off-by-two</id>
    <content type="html"><![CDATA[<p>&ldquo;War stories&rdquo; in programming are entertaining tales of truly evil bugs that
kept you up at night.  Inspired by posts like
<a href="https://www.gamasutra.com/blogs/DaveBaggett/20131031/203788/My_Hardest_Bug_Ever.php">My Hardest Bug Ever</a>,
<a href="https://marcan.st/2017/12/debugging-an-evil-go-runtime-bug/">Debugging an evil Go runtime bug</a>,
and others from
<a href="https://www.reddit.com/r/TalesFromDebugging">/r/TalesFromDebugging</a>, I wanted
to share with you one of my favorites from recent memory.
<a href="https://clangbuiltlinux.github.io/">Recent work</a>
has given me much fulfilment and a long list of truly awful bugs to recount.
My blog has been quieter than I would have liked; hopefully I can find more
time to document some of these, maybe in series form.  May I present to you
episode I; &ldquo;<em>Off by Two</em>.&rdquo;</p>

<hr />

<p>Distracted in a conference grand ballroom, above what might be the largest mall
in the world or at least Bangkok, a blank QEMU session has me seriously
questioning my life choices.  No output.  Fuck!  My freshly built Linux kernel,
built with a large new compiler feature that’s been in development for months
is finally now building but is not booting.  Usually a panic prints a nice
stack trace and we work backwards from there.  I don’t know how to debug a
panic during early boot, and I’ve never had to; with everything I’ve learned up
to this point, I’m afraid I won’t have it in me to debug this.</p>

<p><a href="https://nickdesaulniers.github.io/blog/2018/10/24/booting-a-custom-linux-kernel-in-qemu-and-debugging-it-with-gdb/">Attaching GDB</a>, the kernel’s sitting an infinite loop:</p>

<p>```c
/<em> Restricted version used during very early boot </em>/
void __init early_fixup_exception(struct pt_regs *regs, int trapnr)
{
&hellip;
halt_loop:</p>

<pre><code>while (true)
    halt();
</code></pre>

<p>```</p>

<p>Some sort of very early exception handler; better to sit busy in an infinite
loop than run off and destroy hardware or corrupt data, I suppose.  It seems
this is some sort of exception handler for before we’re ready to properly
panic; maybe the machinery is not in place to even collect a stack trace,
unwind, and print that over the serial driver.  How did things go so wrong and
how did we get here?  I decide to ask for help.</p>

<blockquote><p>Setting breakpoints and rerunning my boot, it looks like the fourth
call to __early_make_pgtable() is deterministically going awry.
Reading through callers, from the early_idt_handler_common subroutine
in arch/x86/kernel/head_64.S the address was stored in %cr2 (the
&ldquo;page fault linear address&rdquo;).  But it’s not clear to me who calculated
that address that created the fault.  My understanding is that
early_idt_handler_common is an exception vector setup in
early_idt_handler_array, which gets invoked upon access to &ldquo;unmapped
memory&rdquo; which gets saved into %cr2.</p></blockquote>

<p>Beyond that, GDB doesn’t want me to be able to read %cr2.</p>

<p><a href="https://thejh.net/">Jann Horn</a> gets back to me first:</p>

<blockquote><p>Can you use QEMU to look at the hardware frame (which contains values pushed
by the hardware in response to the page fault) in early_idt_handler_common?
RSP before the call to early_make_pgtable should basically point to a &ldquo;struct
pt_regs&rdquo;</p>

<p>When the CPU encounters an exception, it pushes an exception frame onto the
stack. That doesn&rsquo;t happen in kernel code; the CPU does that on its own. That
exception frame consists of the last six elements of struct pt_regs. This is
also documented in a comment at the start of early_idt_handler_common
(&ldquo;hardware frame&rdquo; and &ldquo;error code&rdquo; together are the exception frame):</p>

<pre><code>/*
 * The stack is the hardware frame, an error code or zero, and the
 * vector number.
 */
</code></pre>

<p>After the CPU has pushed that stuff, it picks one of the exception handlers
that have been set up in idt_setup_early_handler(); so it jumps to
&amp;early_idt_handler_array[i]. early_idt_handler_array pushes the number of the
interrupt vector, then calls into early_idt_handler_common;
early_idt_handler_common spills the rest of the register state (which is
still the way it was before the exception was triggered) onto the stack
(which among other things involves reading the vector number into a register
and overwriting the stack slot of the vector number with a register that
hasn&rsquo;t been spilled yet).</p>

<p>The combination of the registers that have been spilled by software and the
values that have been pushed onto the stack by the CPU before that forms a
struct pt_regs. (The normal syscall entry slowpath does the same thing, by
the way.)</p>

<p>you’ll want to break on the &ldquo;call early_make_pgtable&rdquo; or something like that,
to get the pt_regs to be fully populated and at RSP.</p></blockquote>

<p>This is documented further in
<a href="https://0xax.gitbooks.io/linux-insides/content/Initialization/linux-initialization-2.html">linux-insides</a>.</p>

<p>So as far as &ldquo;where does the address in %cr2 come from, it’s "the CPU.&rdquo; To get
%cr2, I can just break after an instruction that moves %cr2 into a general
purpose register (GPR).</p>

<p>```c</p>

<pre><code>GET_CR2_INTO(%rdi)  /* can clobber %rax if pv */
call early_make_pgtable
</code></pre>

<p>```</p>

<p><code>sh
$ gdb -batch -ex "file vmlinux" -ex "disassemble
early_idt_handler_common" | grep early_make_pgtable
   0xffffffff82965150 &lt;+48&gt;: callq  0xffffffff829653b9 &lt;early_make_pgtable&gt;
$ gdb vmlinux
...
(gdb) hbreak *0xffffffff82965150
...
(gdb) p/x *(struct pt_regs*)0xffffffff82403e28
$1 = {r15 = 0x0, r14 = 0xffffffff82aa3808, r13 = 0x0, r12 = 0x0, bp = 0x0,
  bx = 0xfffffffc, r11 = 0x2794c5, r10 = 0x20, r9 = 0x13ca62, r8 =
0x20, ax = 0x0,
  cx = 0xffffffff82415700, dx = 0xfffffffb6df881bb, si = 0x0,
  di = 0xffffffff82aa3808, orig_ax = 0x0, ip = 0xffffffff81172b70, cs = 0x10,
  flags = 0x10006, sp = 0xffffffff82403ed8, ss = 0x0}
(gdb) x 0xffffffff81172b70
   0xffffffff81172b70 &lt;jump_label_update+64&gt;: mov    0x8(%rbx),%rsi
(gdb) q
$ objdump -dS vmlinux | grep -B 2 ffffffff81172b70
ffffffff81172b69: 0f 1f 80 00 00 00 00 nopl   0x0(%rax)
if (!mod-&gt;entries)
ffffffff81172b70: 48 8b 73 08          mov    0x8(%rbx),%rsi
</code></p>

<p>Specifically <code>mod</code> in the above expression (ie. <code>rbx</code>) is not pointing to valid
memory in the page tables, triggering an unrecoverable early page fault.</p>

<p>My heart sinks further at the sight of <code>jump_lable_update</code>.  It’s <code>asm goto</code>,
the large compiler feature we’ve been working on for months, and it’s subtly
broken.  Welcome to hell, kids.</p>

<p><code>asm goto</code> is a GNU C extension that allows for assembly code to transfer
control flow to a limited, known set of labels in C code.  Typically, regular
<a href="https://gcc.gnu.org/onlinedocs/gcc/Basic-Asm.html#Basic-Asm"><code>asm</code> statements</a>
(the GNU C extension) are treated as a black box in the instruction stream by
the compiler; they’re called into (not in the sense of the C calling convention
and actual call/jmp/ret instructions) and control flow falls through to the
next instruction outside of the inline assembly.  Then there’s an
&ldquo;<a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Extended-Asm">extended inline assembly</a>&rdquo;
dialect that allows for you to specify input and output constraints (in what
feels like a whole new regex-like language with characters that have
<a href="https://gcc.gnu.org/onlinedocs/gcc/Machine-Constraints.html#Machine-Constraints">architecture specific</a>
or
<a href="https://gcc.gnu.org/onlinedocs/gcc/Simple-Constraints.html#Simple-Constraints">generic</a>
meanings, and requires the reference manual to read or write) and whether to
treat all memory or specific registers otherwise unnamed as outputs as
clobbered.  In the final variant, you may also specify a list of labels that
the assembly may jump control flow to.  There&rsquo;s also <code>printf</code>-like modifiers
called
<a href="https://gcc.gnu.org/onlinedocs/gccint/Output-Template.html#Output-Template">Output Templates</a>,
and a few other tricks that require their own post.</p>

<p>Within the compiler, we can’t really treat <code>asm</code> statements like a black box
anymore.  With <code>asm goto</code>, we have something more akin to structured exception
handling in C++; we’re going to &ldquo;call&rdquo; something, and it may jump control flow
to an arbitrary location.  Well, not arbitrary.  Arbitrary would be an indirect
call through a pointer that could’ve been constructed from any number and may
or may not be a valid instruction (or meant to be interpreted as one, ie. a
&ldquo;gadget.&rdquo;)  <code>asm goto</code> is like virtual method calls or structured expection
handling in C++ in that they all can only transfer control flow to a short list
of possible destinations.</p>

<p>You might be wondering what you can build with this, and why does the Linux
kernel care?  Turns out the Linux kernel has multiple forms of self modifying
code that it uses in multiple different scenarios.  If you do something like:</p>

<p><code>c
asm goto(
  ".pushsection foo\n"
  ".long %l0\n"
  ".popsection\n"
:::comefrom);
comefrom:;
</code></p>

<p>You can squirrel away the address of <code>comefrom</code> in an arbitrary non-standard
ELF section.  Then at runtime if you know how to find ELF sections, you can
lookup <code>foo</code> and find the address of <code>comefrom</code> and then either jump to it, or
modify the instructions it points to.  I’ve used this trick to turn indirect
calls into direct calls (which is super dangerous and has many gotchas).</p>

<p>Luckily, the Linux kernel itself is an ELF executable, with all the machinery
for finding sections (it needs to perform relocations on itself at runtime,
after all), though it does something even simpler with the help of some linker
script magic as we’ll see.</p>

<p><a href="https://lwn.net/Articles/412072/">This LWN article</a> sums up the Linux’s
kernel’s original use case perfectly.</p>

<p>The kernel uses this for replacing runtime evaluation of conditionals with
either unconditional jumps or nop sleds when tracing, which are relatively
&ldquo;expensive&rdquo; to change when enabling or disabling tracing (requires machine wide
synchronization), but has minimally low overhead otherwise at runtime; just
enough nops in a sled to fit a small unconditional relative jump instruction
otherwise.  We can further tell the compiler whether the condition was likely
taken or not, which further influences codegen.</p>

<p>For patching in and out unconditional jumps with nop sleds, the kernel stores
an array of <code>struct jump_entry</code> in a custom  ELF section <code>.jump_table</code>, which
are triplets of:</p>

<ol>
<li>The address of the start of the conditional or nop sled (you can initialize
the branch to be in or out).  The <code>code</code> member of <code>struct jump_entry</code>.</li>
<li>The address of the label to potentially jump to. The <code>target</code> member of
<code>struct jump_entry</code>.  For the case of whether a conditional evaluates to
true or false.</li>
<li>A combination of the address of a global value representing the condition,
and whether the branch is likely to be taken or not.  This is the <code>key</code>
member of <code>struct jump_entry</code>.</li>
</ol>


<p>The kernel uses pointer compression for 1 and 2 above, for architectures that
define <code>CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE</code> as documented near the end of
<a href="https://www.kernel.org/doc/html/latest/x86/exception-tables.html">Documentation/x86/exception-tables.rst</a>.</p>

<p>The kernel uses pointer packing for 3 above, to pack whether the branch is
likely taken or not and the address of a <code>struct static_key</code> as documented in
an ascii art table near the end of include/linux/jump_label.h.  The pointed-to
<code>struct static_key</code> then uses pointer packing again to discriminate members of
an anonymous union, as documented in a comment within the definition of <code>struct
static_key</code> in include/linux/jump_label.h.</p>

<p>Naturally, helper functions exist and must be used for the above 3 cases to
reconstitute pointers from these values.</p>

<p>A custom linker script then defines two symbols that mark the beginning and end
of the section.  These symbols are forward declared in C as symbols with
<code>extern</code> linkage, then used to set boundaries when iterating the array of
<code>struct jump_entry</code> instances, when initializing the keys and when finding an
entry to patch.</p>

<p>Let’s take a quick peek at one architecture’s implementation of creating the
array of <code>struct jump_entry</code> in <code>.jump_table</code>, here’s
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/kernel/jump_label.c">arm64&rsquo;s implementation</a>:</p>

<p>```c
static inline <strong>attribute</strong>((always_inline)) bool arch_static_branch(struct static_key *key,</p>

<pre><code>                                                                 bool branch)
</code></pre>

<p>{</p>

<pre><code>asm volatile goto (
    "1: nop                 \n\t"
     "  .pushsection    __jump_table, \"aw\"    \n\t"
     "  .align      3           \n\t"
     "  .long       1b - ., %l[l_yes] - .   \n\t"
     "  .quad       %c0 - .         \n\t"
     "  .popsection             \n\t"
     :  :  "i"(&amp;((char *)key)[branch]) :  : l_yes);

return false;
</code></pre>

<p>l_yes:</p>

<pre><code>return true;
</code></pre>

<p>}
```</p>

<p>There’s a lot going on here, so let’s take a look.  <code>1:</code> is a local label for
references within the asm block; it will get a temporary symbol name when
emitted.  <code>1:</code> points to a literal nop sled, but after the nop sled is the C
code following the <code>asm goto</code> statement.  That’s because the inline asm uses
the <code>.pushsection</code> directive to store the following data in an ELF section
that’s not <code>.text</code>.  We set the alignment of elements, then store two 32b
values and one 64b.  The <code>.long</code> directive has a comma that’s easy to miss, so
there’s two, and they’re compressed (<code>- .</code>) or made relative offsets of the
current location.  The first is the address of the beginning of the nop sled.
<code>1b</code> means local label named <code>1</code> searching <code>b</code>ackwards.  Finally, we store a
pointer to the <code>struct static_key</code> using pointer packing to add whether we’re
likely to take the branch or not.  The accessor functions will reconstruct the
two separate values correctly.</p>

<p>All this documentation is scattered throughout:</p>

<ul>
<li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/static-keys.txt">Documentation/static-keys.txt</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/x86/exception-tables.html">Documentation/x86/exception-tables.rst</a></li>
<li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/jump_label.h">include/linux/jump_label.h</a></li>
<li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/jump_label.c">kernel/jump_label.c</a></li>
<li>arch/{$ARCH}/include/asm/jump_label.h</li>
<li>arch/{$ARCH}/kernel/jump_label.c</li>
</ul>


<p>In fact, once you know this trick of using <code>.pushsection</code> in extended inline
assembly and storing addresses of data, then using linker defined symbols to
delineate section boundaries for quick searching and iteration, we start to see
this pattern occur all throughout the kernel (with or without <code>asm goto</code>).
<a href="https://lwn.net/Articles/531148/">This LWN article</a> discusses the trick and
the many custom ELF sections of a Linux image well.</p>

<p>Exception tables in the kernel in fact use very similar tricks of storing
addresses in custom ELF sections, <code>__ex_tables</code> and <code>.fixups</code> via inline
assembly.  The Linux kernel also sorts this data in the <code>__ex_table</code> section at
boot or even possibly post-link of the kernel image via BUILDTIME_TABLE_SORT,
so that at runtime the lookup of the exception handler can be done in log(N)
time via binary search! The .fixup also captures the address of the instruction
after the one that caused the exception, in order to possibly return control
flow to after successfully handling the exception.</p>

<p>&ldquo;Alternatives&rdquo; use this for patching in instructions that take advantage of ISA
extensions if we detect support for them at runtime.</p>

<p>A lot of kernel interfaces use function pointers that are written to once, then
either rarely or never modified.  It would be nice to replace these indirect
calls with direct calls.  In fact,
<a href="https://lwn.net/ml/linux-kernel/20200324135603.483964896@infradead.org/">patches have been proposed</a>
to lower the overhead of the Spectre &amp; Meltdown mitigations by doing just that.</p>

<p>Anyways, back to our story of debugging&hellip;</p>

<p>From here, I changed course and pursued another lead.  I had recently taught
LLVM’s inliner how to inline <code>asm goto</code> (or more so, when it was considered
safe to do so).  It seemed that LLVM’s inliner was not always respecting
<code>__attribute__((always_inline))</code> and could simply decide it wasn’t going to
perform an inline substitution.  (The inliner is a complex system; a large
analysis of multiple inputs distilled into a single yes/no signal, and all the
machinery necessary to perform such a code transformation).  The C standard (§
6.7.4
<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2479.pdf">ISO/IEC 9899:202x</a>)
says compilers are allowed to make their own decisions in regards to inline
substitution, so it’s generally more conservative to just say &ldquo;no&rdquo; when
presented with a highly complex or unusual case.</p>

<p>When the &ldquo;always inline&rdquo; function wasn’t inlined, it was no longer semantically
valid, since it was passing its parameters as input to the inline asm using the
&ldquo;i&rdquo; machine agnostic constraint for integral literals, amongst other
questionable uses of <code>__attribute__((always_inline))</code> within the kernel.</p>

<p>I was working around this (before I fixed LLVM) by changing the
<code>__attribute__((always_inline)</code> functions into macros (because the preprocessor
doesn’t have the ability to silently fail to transform as the inliner does).
But everything was working when I did that; the kernel booted just fine.  Had I
regressed something when inlining?  Was there a corner case I wasn’t thinking
of, which happens all the time in compiler development?  Was the compiler
haunted?  Was my code bad? Probably. (Porque no los dos?)</p>

<p>I start bisecting object files used to link the kernel image, mixing code that
is either called a static always inline vs a macro, and I narrow it down to 4
object files.</p>

<ul>
<li>arch/x86/kernel/tsc.o</li>
<li>kernel/time/hrtimer.o</li>
<li>kernel/time/timer.o</li>
<li>kernel/sched/clock.o</li>
</ul>


<p>Reading the time stamp counter! No wonder the kernel is failing so early;
initializing the clocks is one of the earlier tasks the kernel cares about.  A
preemptive multitasking operating system is obsessed with keeping track of
time; you spend up your time slice and you’re scheduled out.</p>

<p>But why would a <code>static inline __attribute__((always_inline))</code> function fail,
but succeed when the function was converted to a macro?</p>

<p>I mentioned this to my colleague Bill Wendling, who spotted a subtle
distinction in LLVM’s IR between the <code>static inline
__attribute__((always_inline))</code> version of the functions (and their call sites)
vs the macro.  Via
<a href="https://lists.llvm.org/pipermail/llvm-dev/2019-April/131518.html">an email to the list</a>:</p>

<blockquote><p>The code below is triggering some weird behavior that&rsquo;s different from how
gcc treats this inline asm. Clang keeps the original type of &ldquo;loc&rdquo; as &ldquo;bool&rdquo;,
which generates an &ldquo;i1 true&rdquo; after inlining. So far so good.  However, during
ISEL, the &ldquo;true&rdquo; is converted to a signed integer. So when it&rsquo;s evaluated,
the result is this:</p>

<pre><code>.quad (42+(-1))-.Ltmp0
</code></pre>

<p>(notice the &ldquo;-1&rdquo;). GCC emits a positive one instead:</p>

<pre><code>.quad 42 + 1 - .Ltmp0
</code></pre>

<p>I&rsquo;m not sure where the problem lies. Should the inline asm promote the &ldquo;i1&rdquo;
to &ldquo;i32&rdquo; during ISEL? Should it be promoted during inlining? Is there a
situation where we require the value to be &ldquo;i1&rdquo;?</p>

<p>-bw</p></blockquote>

<p>```c
typedef _Bool bool;</p>

<p>static inline
<strong>attribute</strong>((<strong>always_inline</strong>))
bool bar(bool loc) {</p>

<pre><code>    asm(".quad 42 + %c0 - .\n\t" : : "i" (loc));
    return 1;
</code></pre>

<p>}</p>

<p>int foo(void) {</p>

<pre><code>    return bar(1);
</code></pre>

<p>}
```
Krzysztof Parzyszek <a href="https://lists.llvm.org/pipermail/llvm-dev/2019-April/131526.html">responded the next day</a>.</p>

<blockquote><p>This is a bug in X86&rsquo;s ISel lowering: it does not take &ldquo;getBooleanContents&rdquo;
into account when extending the immediate value to 64 bits."</p></blockquote>

<p>Oh, shit!  LLVM’s IR has support for arbitrary width integers which is fine for
a high level language.  Because real machines typically don’t have support for
such integers of arbitrary width, the compiler typically has to find legal
widths for these integers (we say it &ldquo;legalizes the types&rdquo;) during lowering
from the high level abstract IR to low level concrete machine code.</p>

<p>To legalize a one bit integer into a 64 bit integer, we have to either zero
extend or sign extend it.  Generally, if we know the signedness of a number, we
sign extend signed integers to preserve the signedness of the uppermost bit, or
zero extend unsigned integers which don’t have a signedness bit to preserve.</p>

<p>But what happens when you have a boolean represented as a signed 1 bit number,
and you choose to sign extend it? <code>0x00</code> becomes <code>0x0000000000000000</code> which is
fine, but <code>0x01</code> becomes <code>0xFFFFFFFFFFFFFFFF</code>, ie. <code>-1</code>.  So when you expected
1, but instead got a -1, then you’re off by 2.  Preceding to use that in an
address calculation is going to result in some spooky bugs.</p>

<p>Recalling our inline <code>asm goto</code>, we we’re using this boolean to construct an
instance of a <code>struct jump_entry</code>’s <code>key</code> member, which was using pointer
packing to both refer to a global address and store whether the branch was
likely taken or not in the LSB.  When the value of <code>branch</code> was 0, we were
fine. But when <code>branch</code> was 1 and we sign extended it to -1, we kept the LSB as
1 but messed up the address of a global variable, resulting in the helper
function unpacking the pointer to a global <code>struct static_key</code> producing a bad
pointer.  Since the bottom two bits were dropped reconstituting the pointer, a
hypothetical value of 0x1001 would become 0xFFC (0x1001 &ndash; 2 &amp; ~3) which would
be wrong by 5 bytes. Thus we were interpreting garbage as a pointer, which led
to cascaded failure.</p>

<p>In this case, it looks like Bill spotted that during instruction selection
something unexpected was occuring, and Krystof narrowed it down from there.
<a href="https://reviews.llvm.org/D60208">Krystof had a fix available for x86</a>, which
<a href="https://reviews.llvm.org/D60224">Kees Cook later extended to all architectures</a>.
Since then,
<a href="https://reviews.llvm.org/D69876">Bill even extended LLVM’s implementation to allow for the mixed use of output constraints with <code>asm goto</code></a>,
something GCC doesn’t yet allow for, which is curious as Clang is now pushing a
GNU C extension further than GCC does.</p>

<p>(The true heroes of this story BTW are Alexander Ivchenko and Mikhail
Dvoretckii for
<a href="https://lists.llvm.org/pipermail/llvm-dev/2018-October/127239.html">providing the initial implementation</a>
of <code>asm goto</code> support in LLVM, and
<a href="https://reviews.llvm.org/D53765">Craig Topper</a> and
<a href="https://reviews.llvm.org/D56571">Jennifer Yu</a> (all Intel) for carrying the
implementation across the finish line.  Kudos to Chandler Carruth for <em>noting
the irony and uncanny coincidence</em> that it was both Intel that
<a href="https://lore.kernel.org/lkml/20180402095033.nfzcrmxvpm46dhbl@gmail.com/">regressed the x86 kernel build with Clang for over a year by requiring <code>asm goto</code> / CONFIG_JUMP_LABEL</a>,
and provided an implementation for it in Clang.)</p>

<p>0 based array indexing is the source of a common programmer error; off by one.
In this case, sign extending a boolean led to our <em>off by two</em>. (Or were we off
by one at being off by one?)</p>

<hr />

<p>I’m lucky to have virtual machines and debuggers, and the ability to introspect
my compiler, but I’m not sure if all of those were available back when Linux
was first written.  For fun, I asked Linus Torvalds what early debugging of the
Linux kernel was like (reprinted with permission):</p>

<p>Nick:</p>

<blockquote><p>What do you do for testing?  Quick boot tests in QEMU are my smoke tests, but
I&rsquo;m always interested in leveling up my workflow.</p></blockquote>

<p>Linus:</p>

<blockquote><p>I basically never do virtual machines. It happens &ndash; but mainly when chasing
kvm bugs. With half of the kernel being drivers, I find the whole &ldquo;run it in
emulation&rdquo; to be kind of pointless from an actual testing perspective.</p>

<p>Yeah, qemu is useful for quick smoke-tests, and for all the automated stuff
that gets run.</p>

<p>But the automation happens on the big farms, and I don&rsquo;t do the quick smoke
testing &ndash; if I get a pull requests from others, it had better be in good
enough shape that something like that is pointless, and when I do my own
development I prefer to think about the code and look at generated assembly
over trying to debug a mistake.</p>

<p>So if something doesn&rsquo;t work for me, that to me is a big red flag &ndash; I go and
really stare at the code and try to understand it even better.  I am not a
huge believer in debuggers, it&rsquo;s not how I&rsquo;ve ever coded.</p>

<p>I feel you get into a mindset where your code is determined by testing and
&ldquo;it works&rdquo;, rather than by actually thinking about it and knowing it and
believing it is correct.</p>

<p>But I probably just make excuses for &ldquo;this is how I started, because
emulation or debuggers just weren&rsquo;t an option originally, and now it&rsquo;s how I
work&rdquo;.</p></blockquote>

<p>Nick:</p>

<blockquote><p>One thing I am curious about is how the hell you ever debugged anything when
you were starting out developing Linux?  Was the first step get something
that could write out to the serial port?  (Do folks use serial debuggers on
x86? USB? We use them often on aarch64.  Not for attaching a debugger, more
so just for dmesg/printk).  Surely, it was some mix of &ldquo;just think really
hard about the code&rdquo; then at some point you had something a little nicer?
Graphics developers frequently have to contend with black screens and use
various colors like all-red/all-green/all-blue when debugging as a lone
signal of what&rsquo;s going wrong, which sucks, but is kind of funny.</p></blockquote>

<p>Linus:</p>

<blockquote><p>Hey, when you make a mistake early on in protected mode, the end result is
generally a triple fault &ndash; which results in an instant reboot.</p>

<p>So my early debugging &ndash; before I had console output and printk &ndash; was
literally &ldquo;let&rsquo;s put an endless loop here&rdquo;, and if the machine locked up you
were successful, and if it rebooted you knew you hadn&rsquo;t reached that point
because something went wrong earlier.</p>

<p>But it&rsquo;s not like doing VGA output was all <em>that</em> complicated, so &ldquo;write one
character to the upper corner of the screen&rdquo; came along pretty quickly. That
gives you a positive &ldquo;yeah, I <em>definitely</em> got this far&rdquo; marker, and not just
a &ldquo;hmm, maybe it locked up even before I got to my endless loop&rdquo;.</p>

<p>Fun days.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Finding compiler bugs with C-Reduce]]></title>
    <link href="http://nickdesaulniers.github.io/blog/2019/01/18/finding-compiler-bugs-with-c-reduce/"/>
    <updated>2019-01-18T00:26:00-08:00</updated>
    <id>http://nickdesaulniers.github.io/blog/2019/01/18/finding-compiler-bugs-with-c-reduce</id>
    <content type="html"><![CDATA[<p>Support for a long awaited GNU C extension,
<a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">asm goto</a>,
is in the midst of landing in
<a href="https://reviews.llvm.org/D56571">Clang</a> and
<a href="https://reviews.llvm.org/D53765">LLVM</a>.  We want to make sure that
we release a high quality implementation, so it&rsquo;s important to test the new
patches on real code and not just small test cases.  When we hit compiler bugs
in large source files, it can be tricky to find exactly what part of
potentially large translation units are problematic.  In this post, we&rsquo;ll take
a look at using
<a href="https://embed.cs.utah.edu/creduce/">C-Reduce</a>,
a multithreaded code bisection utility for C/C++, to help narrow done a
reproducer for
<a href="https://github.com/ClangBuiltLinux/linux/issues/320">a real compiler bug</a>
(potentially; in a patch that was posted, and will be fixed before it can ship
in production) from a real code base (the Linux kernel).  It&rsquo;s mostly a post to
myself in the future, so that I can remind myself how to run C-reduce on the
Linux kernel again, since this is now the third real compiler bug it&rsquo;s helped
me track down.</p>

<p>So the bug I&rsquo;m focusing on when trying to compile the Linux kernel with Clang
is a linkage error, all the way at the end of the build.
<code>
drivers/spi/spidev.o:(__jump_table+0x74): undefined reference to `.Ltmp4'
</code>
Hmm&hellip;looks like the object file (<code>drivers/spi/spidev.o</code>), has a
section (<code>__jump_table</code>), that references a non-existent
symbol (<code>.Ltmp</code>), which looks like a temporary label that should have been
cleaned up by the compiler.  Maybe it was accidentally left behind by an
optimization pass?</p>

<p>To run C-reduce, we need a shell script that returns 0 when it should keep
reducing, and an input file.  For an input file, it&rsquo;s just way simpler to
preprocess it; this helps cut down on the compiler flags that typically
requires paths (<code>-I</code>, <code>-L</code>).</p>

<h2>Preprocess</h2>

<p>First, let&rsquo;s preprocess the source.  For the kernel, if the file compiles
correctly, the kernel&rsquo;s KBuild build process will create a file named in the
form path/to/.file.o.cmd, in our case drivers/spi/.spidev.o.cmd.  (If the file
doesn&rsquo;t compile, then
<a href="https://nickdesaulniers.github.io/blog/2017/05/31/running-clang-tidy-on-the-linux-kernel/">I&rsquo;ve had success</a>
hooking <code>make path/to/file.o</code> with
<a href="https://github.com/rizsotto/Bear">bear</a>
then getting the <code>compile_commands.json</code> for the file.)  I find it easiest to
copy this file to a new shell script, then strip out everything but the first
line.  I then replace the <code>-c -o &lt;output&gt;.o</code> with <code>-E</code>.  <code>chmod +x</code> that new
shell script, then run it (outputting to stdout) to eyeball that it looks
preprocessed, then redirect the output to a <code>.i</code> file.  Now that we have our
preprocessed input, let&rsquo;s create the C-reduce shell script.</p>

<h2>Reproducer</h2>

<p>I find it helpful to have a shell script in the form:</p>

<ol>
<li>remove previous object files</li>
<li>rebuild object files</li>
<li>disassemble object files and pipe to grep</li>
</ol>


<p>For you, it might be some different steps.
<a href="https://embed.cs.utah.edu/creduce/using/">As the docs show</a>,
you just need the shell script to return 0 when it should keep reducing.  From
our previous shell script that pre-processed the source and dumped a <code>.i</code> file,
let&rsquo;s change it back to stop before linking rather that preprocessing
(<code>s/-E/-c/</code>), and change the input to our new <code>.i</code> file.  Finally, let&rsquo;s add
the test for what we want.  Since I want C-Reduce to keep reducing until the
disassmbled object file no longer references anything <code>Ltmp</code> related, I write:</p>

<p><code>sh
$ objdump -Dr -j __jump_table spidev.o | grep Ltmp &gt; /dev/null
</code></p>

<p>Now I can run the reproducer to check that it at least returns 0, which
C-Reduce needs to get started:</p>

<p><code>sh
$ ./spidev_asm_goto.sh
$ echo $?
0
</code></p>

<h2>Running C-Reduce</h2>

<p>Now that we have a reproducer script and input file, let&rsquo;s run C-Reduce.</p>

<p>```
$ time creduce &mdash;n 40 spidev_asm_goto.sh spidev.i
===&lt; 144926 >===
running 40 interestingness tests in parallel
===&lt; pass_includes :: 0 >===
===&lt; pass_unifdef :: 0 >===
===&lt; pass_comments :: 0 >===
===&lt; pass_blank :: 0 >===
(0.7 %, 2393679 bytes)
(5.3 %, 2282207 bytes)
===&lt; pass_clang_binsrch :: replace-function-def-with-decl >===
(12.6 %, 2107372 bytes)
&hellip;
===&lt; pass_indent :: final >===
(100.0 %, 156 bytes)
===================== done ====================</p>

<p>pass statistics:
  method pass_clang_binsrch :: remove-unused-function worked 1 times and failed 0 times
&hellip;
  method pass_lines :: 0 worked 427 times and failed 998 times</p>

<pre><code>        ******** /android0/kernel-all/spidev.i ********
</code></pre>

<p>a() {
  int b;
  c();
  if (c &lt; 2)</p>

<pre><code>b = d();
</code></pre>

<p>  else {</p>

<pre><code>asm goto("1:.long b - ., %l[l_yes] - . \n\t" : : : : l_yes);
</code></pre>

<p>  l_yes:;
  }
  if (b)</p>

<pre><code>e();
</code></pre>

<p>}
creduce &mdash;n 40 spidev_asm_goto.sh spidev.i  1892.35s user 1186.10s system 817% cpu 6:16.76 total
$ wc -l spidev.i.orig
56160 spidev.i.orig
$ wc -l spidev.i
12 spidev.i
```</p>

<p>So it took C-reduce just over 6 minutes to turn >56k lines of mostly irrelevant
code into 12 when running 40 threads on my 48 core workstation.</p>

<p>It&rsquo;s also highly entertaining to watch C-Reduce work its magic. In another
terminal, I highly recommend running <code>watch -n1 cat &lt;input_file_to_creduce.i&gt;</code>
to see it pared down before your eyes.</p>

<p>Jump to 4:24 to see where things really pick up.
<a href="https://asciinema.org/a/XtD0QdiIUGhvc1G2BqTJ9gti2"><img src="https://asciinema.org/a/XtD0QdiIUGhvc1G2BqTJ9gti2.svg" alt="asciicast" /></a>
<a href="https://asciinema.org/a/zdkbvUqDsilSa5QjGJr3ANP6y"><img src="https://asciinema.org/a/zdkbvUqDsilSa5QjGJr3ANP6y.svg" alt="asciicast" /></a></p>

<p>Finally, we still want to bisect our compiler flags (the kernel uses a lot).  I
still do this process manually, and it&rsquo;s not too bad.  Having proper and
minimal steps to reproduce compiler bugs is critical.</p>

<p>That&rsquo;s enough for a great bug report for now.  In a future episode, we&rsquo;ll see
how to start pulling apart llvm to see where compilation is going amiss.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GCC vs LLVM Q3 2017: Active Developer Counts]]></title>
    <link href="http://nickdesaulniers.github.io/blog/2017/09/05/gcc-vs-llvm-q3-2017-commit-rates-and-active-developer-counts/"/>
    <updated>2017-09-05T00:20:00-07:00</updated>
    <id>http://nickdesaulniers.github.io/blog/2017/09/05/gcc-vs-llvm-q3-2017-commit-rates-and-active-developer-counts</id>
    <content type="html"><![CDATA[<p>A blog post from a few years ago that really stuck with me was Martin Olsson’s
<a href="https://mo.github.io/2015/11/04/browser-engines-active-developers-and-commit-rates.html">Browser Engines 2015: Commit Rates and Active Developer Counts</a>,
where he shows information about the number of authors and commits to popular
web browsers.  The graphs and analysis had interesting takeaways like showing
the obvious split in blink and webkit, and relative number of contributors of
the projects.  Martin had data comparing gcc to llvm from Q4 2015, but I wanted
to see what the data looked like now in Q3 2017 and wanted to share my
findings; simply rerunning the numbers.  Luckily Martin
<a href="https://github.com/mo/git-source-metrics">open sourced</a>
the scripts he used for measurements so they could be rerun.</p>

<p>Commit count and active authors in the previous 60 days is a rough estimate for
project health; the scripts don’t/can’t account for unique authors (same author
using different git commit info) and commit frequency is meaningless for
comparing developers that commit early and commit often, but let’s take a look.
Active contributors over 60 days cuts out folks who do commit to either code
bases, just not as often.  Lies, damn lies, and statistics, right? Or torture
the data enough, and it will confess anything&hellip;</p>

<p>Note that LLVM is split into a few repositories (llvm the common base, clang
the C/C++ frontend, libc++ the C++ runtime, compiler-rt the
sanitizers/built-ins/profiler lib, lld the linker, clang-tools-extra the
utility belt, lldb the debugger (there are more, these are the most active LLVM
projects)).  Later, I refer to LLVM as the grouping of these repos.</p>

<p>There’s a lot of caveats with this data.  I suspect that the separate LLVM
repo’s have a lot of overlap and have fewer active contributors when looked at
in aggregate.  That is to say you can’t simply add them else you’d be double
counting a bunch.  Also, the comparison is not quite fair since the overlap in
front-end-language and back-end-target support in these two massive projects
does not overlap in a lot of places.</p>

<p><img class="center" src="/images/gcc_clang_authors.jpg"></p>

<p>LLVM’s 60 day active contributors are ~3x-5x times GCC’s and growing, while
GCC’s 100-count hasn’t changed much since ‘04.  It’s safe to say GCC is not
dying; it’s going steady and chugging away as it has been, but it seems LLVM
has been very strong in attracting active contributors.  Either way, I’m
thankful to have not one, but two high quality open source C/C++ compilers.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Running Clang-Tidy on the Linux Kernel]]></title>
    <link href="http://nickdesaulniers.github.io/blog/2017/05/31/running-clang-tidy-on-the-linux-kernel/"/>
    <updated>2017-05-31T20:25:00-07:00</updated>
    <id>http://nickdesaulniers.github.io/blog/2017/05/31/running-clang-tidy-on-the-linux-kernel</id>
    <content type="html"><![CDATA[<p><a href="http://clang.llvm.org/extra/clang-tidy/">Clang-Tidy</a> is a linter from the LLVM
ecosystem.  I wanted to try to run it on the Linux kernel to see what kind of
bugs it would find.  The false positive rate seems pretty high (a persistent
bane to static analysis), but some patching in both the tooling and the source
can likely help bring this rate down.</p>

<p>The most straightforward way to invoke Clang-Tidy is with a compilation
database, which is a json based file that for each translation unit records</p>

<ol>
<li>The source file of the translation unit.</li>
<li>The top level directory of the source.</li>
<li>The exact arguments passed to the compiler.</li>
</ol>


<p>The exact arguments are required because <code>-D</code> and <code>-I</code> flags are necessary to
reproduce the exact Abstract Syntax Tree (AST) used to compile your code. Given
a compilation database, it&rsquo;s trivial to parse and recreate a build.  For the
kernel&rsquo;s KBuild, it&rsquo;s a lot like encoding the output of <code>make V=1</code>.</p>

<p>In order to generate a compilation database, we can use an awesome tool called
<a href="https://github.com/rizsotto/Bear">BEAR</a>. BEAR will
<a href="https://github.com/rizsotto/Bear/blob/6b07f5044f30a3070d1dc39801bcdd94395d673e/libear/ear.c#L21">hook</a>
calls to
<a href="https://linux.die.net/man/3/exec">exec</a>
and family, then write out the compilation database (compile_commands.json).</p>

<p>With BEAR installed, we can invoke the kernel&rsquo;s build with <code>bear make -j</code>. When
we&rsquo;re done:</p>

<p>```sh
➜  linux git:(nick) ✗ du -h compile_commands.json
11M compile_commands.json
➜  linux git:(nick) ✗ wc -l compile_commands.json
330296 compile_commands.json
➜  linux git:(nick) ✗ head -n 26 compile_commands.json
[</p>

<pre><code>{
    "arguments": [
        "cc",
        "-c",
        "-Wp,-MD,arch/x86/boot/tools/.build.d",
        "-Wall",
        "-Wmissing-prototypes",
        "-Wstrict-prototypes",
        "-O2",
        "-fomit-frame-pointer",
        "-std=gnu89",
        "-Wno-unused-value",
        "-Wno-unused-parameter",
        "-Wno-missing-field-initializers",
        "-I./tools/include",
        "-include",
        "include/generated/autoconf.h",
        "-D__EXPORTED_HEADERS__",
        "-o",
        "arch/x86/boot/tools/build",
        "arch/x86/boot/tools/build.c"
    ],
    "directory": "/home/nick/linux",
    "file": "arch/x86/boot/tools/build.c"
},
</code></pre>

<p>```</p>

<p>Now with Clang-Tidy (probably worthwhile to build from source, but it&rsquo;s also
available off <code>apt</code>), we want to grab
<a href="https://github.com/llvm-mirror/clang-tools-extra/blob/master/clang-tidy/tool/run-clang-tidy.py">this helper script, run-clang-tidy.py</a>
to help analyze all this code.</p>

<p><code>sh
curl -O https://raw.githubusercontent.com/llvm-mirror/clang-tools-extra/master/clang-tidy/tool/run-clang-tidy.py
</code></p>

<p>Then we can run it from the same directory as compile_commands.json:</p>

<p>```sh
python run-clang-tidy.py \
  -clang-tidy-binary /usr/bin/clang-tidy-4.0 \</p>

<blockquote><p>clang_tidy_output.txt
```</p></blockquote>

<p>This took about 1hr12min on my box. Let&rsquo;s see what the damage is:</p>

<p>```sh
➜  linux git:(nick) ✗ cat clang_tidy_output.txt \
  | grep warning: | grep -oE &lsquo;[^ ]+$&rsquo; | sort | uniq -c</p>

<pre><code> 76 [clang-analyzer-core.CallAndMessage]
 15 [clang-analyzer-core.DivideZero]
  1 [clang-analyzer-core.NonNullParamChecker]
316 [clang-analyzer-core.NullDereference]
 90 [clang-analyzer-core.UndefinedBinaryOperatorResult]
  1 [clang-analyzer-core.uninitialized.ArraySubscript]
</code></pre>

<p>   1410 [clang-analyzer-core.uninitialized.Assign]</p>

<pre><code> 10 [clang-analyzer-core.uninitialized.Branch]
  5 [clang-analyzer-core.uninitialized.UndefReturn]
 11 [clang-analyzer-cplusplus.NewDeleteLeaks]
694 [clang-analyzer-deadcode.DeadStores]
342 [clang-analyzer-security.insecureAPI.strcpy]
  2 [clang-analyzer-unix.API]
 11 [clang-analyzer-unix.Malloc]
  4 [clang-diagnostic-address-of-packed-member]
  2 [clang-diagnostic-duplicate-decl-specifier]
 98 [clang-diagnostic-implicit-int]
</code></pre>

<p>```</p>

<p>Looking through the output, there&rsquo;s seems to be almost nothing but false
positives, but who knows, maybe there&rsquo;s an actual bug or two in there.  Likely
possible patches to LLVM, its checkers, or the Linux kernel could lower the
false positive ratio.</p>

<p>If you&rsquo;re interested in seeing the kinds of warnings/outputs, I&rsquo;ve uploaded my
results run on a 4.12-rc3 based kernel that may or may not have been compiled
with Clang to
<a href="https://github.com/nickdesaulniers/linux/blob/clang_tidy/clang_tidy_output.txt.v2">my clang_tidy branch of the kernel on GitHub</a>.
As in my sorted output, I find it handy to <code>grep</code> for <code>warning:</code>. Maybe you can
find yourself a good first bug to
<a href="blog/2017/05/16/submitting-your-first-patch-to-the-linux-kernel-and-responding-to-feedback/">contribute a fix to the kernel</a>?</p>

<p>There&rsquo;s likely also
<a href="http://clang.llvm.org/extra/clang-tidy/checks/list.html">some checks that make sense to disable or enable</a>.
Clang-Tidy also allows you to
<a href="http://clang.llvm.org/extra/clang-tidy/#writing-a-clang-tidy-check">write and use your own checkers</a>.
Who knows, someone may just end up writing static
analyses tailored to the Linux kernel.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Additional C/C++ Tooling]]></title>
    <link href="http://nickdesaulniers.github.io/blog/2015/07/23/additional-c-slash-c-plus-plus-tooling/"/>
    <updated>2015-07-23T21:10:00-07:00</updated>
    <id>http://nickdesaulniers.github.io/blog/2015/07/23/additional-c-slash-c-plus-plus-tooling</id>
    <content type="html"><![CDATA[<p><a href="http://shop.oreilly.com/product/0636920025108.do">21st Century C by Ben Klemens</a>
was a great read. It had a section with an
intro to autotools, git, and gdb.
There are a few other useful tools that came to mind that I&rsquo;ve used when
working with C and C++ codebases. These tools are a great way to start
contributing to
<a href="https://github.com/nickdesaulniers/What-Open-Source-Means-To-Me#what-open-source-means-to-me">Open Source</a>
C &amp; C++ codebases; running these tools on
the code or adding them to the codebases.  A lot of these favor command line,
open source utilities. See how many you are familiar with!</p>

<h2>Build Tools</h2>

<h3>CMake</h3>

<p>The first tool I&rsquo;d like to take a look at is
<a href="http://www.cmake.org/overview/">CMake</a>.  CMake is yet another build tool; I
realize how contentious it is to even discuss one of the many.  From my
experience working with
<a href="https://kripken.github.io/emscripten-site/docs/introducing_emscripten/about_emscripten.html">Emscripten</a>,
we recommend the use of CMake for people
writing portable C/C++ programs.  CMake is able to emit Makefiles for unixes,
project files for Xcode on OSX, and project files for Visual Studio on Windows.
There are also a few other &ldquo;generators&rdquo; that you can use.</p>

<p>I&rsquo;ve been really impressed with CMake&rsquo;s modules for
<a href="http://www.cmake.org/cmake/help/v3.0/command/find_package.html">finding dependencies</a>
and
<a href="http://www.cmake.org/cmake/help/v3.0/module/ExternalProject.html">another for fetching and building external dependencies</a>.
I think
<a href="https://www.youtube.com/watch?v=nshzjMDD79w">C++ needs a package manager badly</a>,
and I think CMake would be a solid foundation for one.</p>

<p>The syntax isn&rsquo;t the greatest, but when I wanted to try to build one of my C++
projects on Windows which I know nothing about developing on, I was able to
install CMake and Visual Studio and get my project building.  If you can build
your code on one platform, it will usually build on the others.</p>

<p>If you&rsquo;re not worried about writing cross platform C/C++, maybe CMake is not
worth the effort, but I find it useful.  I wrestle with the syntax sometimes,
but documentation is not bad and it&rsquo;s something you deal with early on in the
development of a project and hopefully never have to touch again (how I wish
that were true).</p>

<h2>Code Formatters</h2>

<h3>ClangFormat</h3>

<p>Another contentious point of concern amongst developers is code style.
<a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.html">Big companies</a>
with lots of C++ code have
<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Coding_Style#CC_practices">documents</a>
explaining their stylistic choices.  Don&rsquo;t waste another hour of your life
arguing about something that really doesn&rsquo;t matter.
<a href="http://clang.llvm.org/docs/ClangFormat.html">ClangFormat</a> will help you
codify your style and format your code for you to match the style.  Simply
write the code however you want, and run the formatter on it before commiting
it.</p>

<p>It can also emit a .clang-format file that you can commit and clang-format will automatically look for that file and use the rules codified there.</p>

<h2>Linters</h2>

<h3>Flint / Flint++</h3>

<p><a href="https://github.com/facebook/flint">Flint</a> is a C++ linter in use at Facebook.
Since it moved from being
implemented in C++ to D, I&rsquo;ve had issues building it.  I&rsquo;ve had better luck
with a fork that&rsquo;s pure C++ without any of the third party dependencies Flint
originally had, called
<a href="https://github.com/L2Program/FlintPlusPlus">Flint++</a>.  While not quite full-on
static analyzers, both can be used for finding potential issues in your code
ahead of time. Linters can look at individual files in isolation; you don&rsquo;t
have to wait for long recompiles like you would with a static analyzer.</p>

<h2>Static Analyzers</h2>

<h3>Scan-build</h3>

<p><a href="http://clang-analyzer.llvm.org/scan-build.html">Scan-build</a> is a static
analyzer for C and C++ code.  You build your code &ldquo;through&rdquo; it, then use the
sibling tool scan-view to see the results.  Scan-view will emit and open an
html file that shows a list of the errors it detected.  It will insert
hyperlinks into the resulting document that step you through how certain
conditions could lead to a null pointer dereference, for example.  You can also
save and share those html files with others in the project. Static analyzers
will help you catch bugs at compile time before you run the code.</p>

<h2>Runtime Sanitizers</h2>

<h3>ASan and UBSan</h3>

<p>Clang&rsquo;s Address (ASan) and Undefined Behavior (UBSan) sanitizers are simply
compiler flags that can be used to detect errors at runtime.  ASan and UBSan
two of the more popular tools, but there are actually a ton and more being
implemented.  See the list
<a href="http://clang.llvm.org/docs/UsersManual.html#controlling-code-generation">here</a>.
These sanitizers will catch bugs at runtime, so you&rsquo;ll have to run the code
to notice any violations, at variable runtime performance costs per sanitizer.
ASan and TSan (Thread Sanitizer) made it into gcc4.8 and UBSan is in gcc4.9.</p>

<h2>Header Analysis</h2>

<h3>Include What You Use</h3>

<p><a href="https://github.com/include-what-you-use/include-what-you-use">Include What You Use</a>
(IWYU) helps you find unused or unnecessary <code>#include</code> preprocessor directives.
It should be obvious how this can help improve compile times. IWYU can also
help cut down on recompiles by recommending forward declarations under certain
conditions.
I look forward to the C++ module proposal being adopted, but until then this
tool can help you spot cruft that can be removed.</p>

<h2>Rapid Recompiles</h2>

<h3>ccache</h3>

<p><a href="https://ccache.samba.org/">ccache</a> greatly improves recompile times by caching
the results of parts of the compilation process.
<a href="https://github.com/nickdesaulniers/dotfiles/blob/49984b3e82022e5ce82e778fc8ce990f8e1e554a/.mozconfig#L1">I use when building Firefox</a>,
and it saves a great deal of time.</p>

<h3>distcc</h3>

<p><a href="https://github.com/distcc/distcc">distcc</a> is a distributed build system.
<a href="http://blog.dholbert.org/">Some folks at Mozilla</a> speed up their Firefox builds with it.</p>

<h2>Memory Leak Detectors</h2>

<h3>Valgrind</h3>

<p><a href="http://valgrind.org/info/about.html">Valgrind</a> has a
<a href="http://valgrind.org/info/about.html">suite of tools</a>, my
favorite being memcheck for finding memory leaks. Unfortunately, it doesn&rsquo;t
seem to work on OSX since 10.10.
<a href="https://code.google.com/p/address-sanitizer/wiki/ComparisonOfMemoryTools">This page</a>
referring to ASan seems to indicate that it can do everything Valgrind&rsquo;s
Memcheck can, at less of a runtime performance cost, but I&rsquo;m not sure how true
this is exactly.</p>

<h3>leaks</h3>

<p>A much more primitive tool for finding leaks from the command line, BSD&rsquo;s have
<code>leaks</code>.</p>

<p><code>bash
MallocStackLogging=1 ./a.out
leaks a.out
...
</code></p>

<h2>Profilers</h2>

<h3>Perf</h3>

<p>Perf, and
<a href="http://www.brendangregg.com/flamegraphs.html">Brendan Gregg&rsquo;s tools for emitting SVG flamegraphs</a>
from the output
are helpful for finding where time is spent in a program. In fact, there are
numerous perfomance analysis tools that are Linux specific.  My recommendation
is spend some time on <a href="http://www.brendangregg.com/linuxperf.html">Brendan Gregg&rsquo;s blog</a>.</p>

<h3>DTrace</h3>

<p>OSX doesn&rsquo;t have the same tooling as Linux, but DTrace was ported to it.  I&rsquo;ve
used it to find sampling profiles of my code before. Again,
<a href="http://www.brendangregg.com/dtrace.html">Brendan Gregg&rsquo;s blog</a> is a good
resource; there are some fantastic DTrace one liners.</p>

<h2>Debuggers</h2>

<h3>lldb</h3>

<p>lldb is analogous to gdb.  I can&rsquo;t say I have enough experience with LLDB and GDB to note the difference between the two, but LLDB did show the relative statements forward and back from the current statement by default.  I&rsquo;m informed by my friends/mortal enemies using emacs that this is less of an issue when using emacs/gdb in combination.</p>

<h2>Fuzzers</h2>

<h3>American Fuzzy Lop</h3>

<p><a href="http://lcamtuf.coredump.cx/afl/">American Fuzzy Lop</a> (AFL) is a neat program
that performs fuzzing on programs
that take inputs from files and repeatedly runs the program, modifies the
input trying to get full code coverage, and tries to find crashes.  It&rsquo;s been
getting lots of attention lately, and while I haven&rsquo;t used it myself yet, it
seems like a very powerful tool. Mozilla employs the use of fuzzers on their
JavaScript engine, for instance (not AFL, but
<a href="http://www.squarefree.com/2007/08/02/introducing-jsfunfuzz/">one developed in house</a>).</p>

<h2>Disassemblers</h2>

<h3>gobjdump</h3>

<p>If you really need to make sure the higher level code you&rsquo;re writing is getting
translated into the assembly your expecting, <code>gobjdump -S</code> will intermix the
emitted binary&rsquo;s disassembled assembly and the source code.  This was used
extensively while developing <a href="/blog/2015/05/25/interpreter-compiler-jit/">my Brainfuck JIT</a>.</p>

<h2>Conclusion</h2>

<p>Hopefully you learned of some useful tools that you should know about when
working with C or C++.  What did I miss?</p>
]]></content>
  </entry>
  
</feed>
