<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: asm | Nick Desaulniers]]></title>
  <link href="http://nickdesaulniers.github.io/blog/categories/asm/atom.xml" rel="self"/>
  <link href="http://nickdesaulniers.github.io/"/>
  <updated>2020-04-06T08:08:18-07:00</updated>
  <id>http://nickdesaulniers.github.io/</id>
  <author>
    <name><![CDATA[Nick Desaulniers]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Off by Two]]></title>
    <link href="http://nickdesaulniers.github.io/blog/2020/04/06/off-by-two/"/>
    <updated>2020-04-06T07:32:00-07:00</updated>
    <id>http://nickdesaulniers.github.io/blog/2020/04/06/off-by-two</id>
    <content type="html"><![CDATA[<p>&ldquo;War stories&rdquo; in programming are entertaining tales of truly evil bugs that
kept you up at night.  Inspired by posts like
<a href="https://www.gamasutra.com/blogs/DaveBaggett/20131031/203788/My_Hardest_Bug_Ever.php">My Hardest Bug Ever</a>,
<a href="https://marcan.st/2017/12/debugging-an-evil-go-runtime-bug/">Debugging an evil Go runtime bug</a>,
and others from
<a href="https://www.reddit.com/r/TalesFromDebugging">/r/TalesFromDebugging</a>, I wanted
to share with you one of my favorites from recent memory.
<a href="https://clangbuiltlinux.github.io/">Recent work</a>
has given me much fulfilment and a long list of truly awful bugs to recount.
My blog has been quieter than I would have liked; hopefully I can find more
time to document some of these, maybe in series form.  May I present to you
episode I; &ldquo;<em>Off by Two</em>.&rdquo;</p>

<hr />

<p>Distracted in a conference grand ballroom, above what might be the largest mall
in the world or at least Bangkok, a blank QEMU session has me seriously
questioning my life choices.  No output.  Fuck!  My freshly built Linux kernel,
built with a large new compiler feature that’s been in development for months
is finally now building but is not booting.  Usually a panic prints a nice
stack trace and we work backwards from there.  I don’t know how to debug a
panic during early boot, and I’ve never had to; with everything I’ve learned up
to this point, I’m afraid I won’t have it in me to debug this.</p>

<p><a href="https://nickdesaulniers.github.io/blog/2018/10/24/booting-a-custom-linux-kernel-in-qemu-and-debugging-it-with-gdb/">Attaching GDB</a>, the kernel’s sitting an infinite loop:</p>

<p>```c
/<em> Restricted version used during very early boot </em>/
void __init early_fixup_exception(struct pt_regs *regs, int trapnr)
{
&hellip;
halt_loop:</p>

<pre><code>while (true)
    halt();
</code></pre>

<p>```</p>

<p>Some sort of very early exception handler; better to sit busy in an infinite
loop than run off and destroy hardware or corrupt data, I suppose.  It seems
this is some sort of exception handler for before we’re ready to properly
panic; maybe the machinery is not in place to even collect a stack trace,
unwind, and print that over the serial driver.  How did things go so wrong and
how did we get here?  I decide to ask for help.</p>

<blockquote><p>Setting breakpoints and rerunning my boot, it looks like the fourth
call to __early_make_pgtable() is deterministically going awry.
Reading through callers, from the early_idt_handler_common subroutine
in arch/x86/kernel/head_64.S the address was stored in %cr2 (the
&ldquo;page fault linear address&rdquo;).  But it’s not clear to me who calculated
that address that created the fault.  My understanding is that
early_idt_handler_common is an exception vector setup in
early_idt_handler_array, which gets invoked upon access to &ldquo;unmapped
memory&rdquo; which gets saved into %cr2.</p></blockquote>

<p>Beyond that, GDB doesn’t want me to be able to read %cr2.</p>

<p><a href="https://thejh.net/">Jann Horn</a> gets back to me first:</p>

<blockquote><p>Can you use QEMU to look at the hardware frame (which contains values pushed
by the hardware in response to the page fault) in early_idt_handler_common?
RSP before the call to early_make_pgtable should basically point to a &ldquo;struct
pt_regs&rdquo;</p>

<p>When the CPU encounters an exception, it pushes an exception frame onto the
stack. That doesn&rsquo;t happen in kernel code; the CPU does that on its own. That
exception frame consists of the last six elements of struct pt_regs. This is
also documented in a comment at the start of early_idt_handler_common
(&ldquo;hardware frame&rdquo; and &ldquo;error code&rdquo; together are the exception frame):</p>

<pre><code>/*
 * The stack is the hardware frame, an error code or zero, and the
 * vector number.
 */
</code></pre>

<p>After the CPU has pushed that stuff, it picks one of the exception handlers
that have been set up in idt_setup_early_handler(); so it jumps to
&amp;early_idt_handler_array[i]. early_idt_handler_array pushes the number of the
interrupt vector, then calls into early_idt_handler_common;
early_idt_handler_common spills the rest of the register state (which is
still the way it was before the exception was triggered) onto the stack
(which among other things involves reading the vector number into a register
and overwriting the stack slot of the vector number with a register that
hasn&rsquo;t been spilled yet).</p>

<p>The combination of the registers that have been spilled by software and the
values that have been pushed onto the stack by the CPU before that forms a
struct pt_regs. (The normal syscall entry slowpath does the same thing, by
the way.)</p>

<p>you’ll want to break on the &ldquo;call early_make_pgtable&rdquo; or something like that,
to get the pt_regs to be fully populated and at RSP.</p></blockquote>

<p>This is documented further in
<a href="https://0xax.gitbooks.io/linux-insides/content/Initialization/linux-initialization-2.html">linux-insides</a>.</p>

<p>So as far as &ldquo;where does the address in %cr2 come from, it’s "the CPU.&rdquo; To get
%cr2, I can just break after an instruction that moves %cr2 into a general
purpose register (GPR).</p>

<p>```c</p>

<pre><code>GET_CR2_INTO(%rdi)  /* can clobber %rax if pv */
call early_make_pgtable
</code></pre>

<p>```</p>

<p><code>sh
$ gdb -batch -ex "file vmlinux" -ex "disassemble
early_idt_handler_common" | grep early_make_pgtable
   0xffffffff82965150 &lt;+48&gt;: callq  0xffffffff829653b9 &lt;early_make_pgtable&gt;
$ gdb vmlinux
...
(gdb) hbreak *0xffffffff82965150
...
(gdb) p/x *(struct pt_regs*)0xffffffff82403e28
$1 = {r15 = 0x0, r14 = 0xffffffff82aa3808, r13 = 0x0, r12 = 0x0, bp = 0x0,
  bx = 0xfffffffc, r11 = 0x2794c5, r10 = 0x20, r9 = 0x13ca62, r8 =
0x20, ax = 0x0,
  cx = 0xffffffff82415700, dx = 0xfffffffb6df881bb, si = 0x0,
  di = 0xffffffff82aa3808, orig_ax = 0x0, ip = 0xffffffff81172b70, cs = 0x10,
  flags = 0x10006, sp = 0xffffffff82403ed8, ss = 0x0}
(gdb) x 0xffffffff81172b70
   0xffffffff81172b70 &lt;jump_label_update+64&gt;: mov    0x8(%rbx),%rsi
(gdb) q
$ objdump -dS vmlinux | grep -B 2 ffffffff81172b70
ffffffff81172b69: 0f 1f 80 00 00 00 00 nopl   0x0(%rax)
if (!mod-&gt;entries)
ffffffff81172b70: 48 8b 73 08          mov    0x8(%rbx),%rsi
</code></p>

<p>Specifically <code>mod</code> in the above expression (ie. <code>rbx</code>) is not pointing to valid
memory in the page tables, triggering an unrecoverable early page fault.</p>

<p>My heart sinks further at the sight of <code>jump_lable_update</code>.  It’s <code>asm goto</code>,
the large compiler feature we’ve been working on for months, and it’s subtly
broken.  Welcome to hell, kids.</p>

<p><code>asm goto</code> is a GNU C extension that allows for assembly code to transfer
control flow to a limited, known set of labels in C code.  Typically, regular
<a href="https://gcc.gnu.org/onlinedocs/gcc/Basic-Asm.html#Basic-Asm"><code>asm</code> statements</a>
(the GNU C extension) are treated as a black box in the instruction stream by
the compiler; they’re called into (not in the sense of the C calling convention
and actual call/jmp/ret instructions) and control flow falls through to the
next instruction outside of the inline assembly.  Then there’s an
&ldquo;<a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Extended-Asm">extended inline assembly</a>&rdquo;
dialect that allows for you to specify input and output constraints (in what
feels like a whole new regex-like language with characters that have
<a href="https://gcc.gnu.org/onlinedocs/gcc/Machine-Constraints.html#Machine-Constraints">architecture specific</a>
or
<a href="https://gcc.gnu.org/onlinedocs/gcc/Simple-Constraints.html#Simple-Constraints">generic</a>
meanings, and requires the reference manual to read or write) and whether to
treat all memory or specific registers otherwise unnamed as outputs as
clobbered.  In the final variant, you may also specify a list of labels that
the assembly may jump control flow to.  There&rsquo;s also <code>printf</code>-like modifiers
called
<a href="https://gcc.gnu.org/onlinedocs/gccint/Output-Template.html#Output-Template">Output Templates</a>,
and a few other tricks that require their own post.</p>

<p>Within the compiler, we can’t really treat <code>asm</code> statements like a black box
anymore.  With <code>asm goto</code>, we have something more akin to structured exception
handling in C++; we’re going to &ldquo;call&rdquo; something, and it may jump control flow
to an arbitrary location.  Well, not arbitrary.  Arbitrary would be an indirect
call through a pointer that could’ve been constructed from any number and may
or may not be a valid instruction (or meant to be interpreted as one, ie. a
&ldquo;gadget.&rdquo;)  <code>asm goto</code> is like virtual method calls or structured expection
handling in C++ in that they all can only transfer control flow to a short list
of possible destinations.</p>

<p>You might be wondering what you can build with this, and why does the Linux
kernel care?  Turns out the Linux kernel has multiple forms of self modifying
code that it uses in multiple different scenarios.  If you do something like:</p>

<p><code>c
asm goto(
  ".pushsection foo\n"
  ".long %l0\n"
  ".popsection\n"
:::comefrom);
comefrom:;
</code></p>

<p>You can squirrel away the address of <code>comefrom</code> in an arbitrary non-standard
ELF section.  Then at runtime if you know how to find ELF sections, you can
lookup <code>foo</code> and find the address of <code>comefrom</code> and then either jump to it, or
modify the instructions it points to.  I’ve used this trick to turn indirect
calls into direct calls (which is super dangerous and has many gotchas).</p>

<p>Luckily, the Linux kernel itself is an ELF executable, with all the machinery
for finding sections (it needs to perform relocations on itself at runtime,
after all), though it does something even simpler with the help of some linker
script magic as we’ll see.</p>

<p><a href="https://lwn.net/Articles/412072/">This LWN article</a> sums up the Linux’s
kernel’s original use case perfectly.</p>

<p>The kernel uses this for replacing runtime evaluation of conditionals with
either unconditional jumps or nop sleds when tracing, which are relatively
&ldquo;expensive&rdquo; to change when enabling or disabling tracing (requires machine wide
synchronization), but has minimally low overhead otherwise at runtime; just
enough nops in a sled to fit a small unconditional relative jump instruction
otherwise.  We can further tell the compiler whether the condition was likely
taken or not, which further influences codegen.</p>

<p>For patching in and out unconditional jumps with nop sleds, the kernel stores
an array of <code>struct jump_entry</code> in a custom  ELF section <code>.jump_table</code>, which
are triplets of:</p>

<ol>
<li>The address of the start of the conditional or nop sled (you can initialize
the branch to be in or out).  The <code>code</code> member of <code>struct jump_entry</code>.</li>
<li>The address of the label to potentially jump to. The <code>target</code> member of
<code>struct jump_entry</code>.  For the case of whether a conditional evaluates to
true or false.</li>
<li>A combination of the address of a global value representing the condition,
and whether the branch is likely to be taken or not.  This is the <code>key</code>
member of <code>struct jump_entry</code>.</li>
</ol>


<p>The kernel uses pointer compression for 1 and 2 above, for architectures that
define <code>CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE</code> as documented near the end of
<a href="https://www.kernel.org/doc/html/latest/x86/exception-tables.html">Documentation/x86/exception-tables.rst</a>.</p>

<p>The kernel uses pointer packing for 3 above, to pack whether the branch is
likely taken or not and the address of a <code>struct static_key</code> as documented in
an ascii art table near the end of include/linux/jump_label.h.  The pointed-to
<code>struct static_key</code> then uses pointer packing again to discriminate members of
an anonymous union, as documented in a comment within the definition of <code>struct
static_key</code> in include/linux/jump_label.h.</p>

<p>Naturally, helper functions exist and must be used for the above 3 cases to
reconstitute pointers from these values.</p>

<p>A custom linker script then defines two symbols that mark the beginning and end
of the section.  These symbols are forward declared in C as symbols with
<code>extern</code> linkage, then used to set boundaries when iterating the array of
<code>struct jump_entry</code> instances, when initializing the keys and when finding an
entry to patch.</p>

<p>Let’s take a quick peek at one architecture’s implementation of creating the
array of <code>struct jump_entry</code> in <code>.jump_table</code>, here’s
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/kernel/jump_label.c">arm64&rsquo;s implementation</a>:</p>

<p>```c
static inline <strong>attribute</strong>((always_inline)) bool arch_static_branch(struct static_key *key,</p>

<pre><code>                                                                 bool branch)
</code></pre>

<p>{</p>

<pre><code>asm volatile goto (
    "1: nop                 \n\t"
     "  .pushsection    __jump_table, \"aw\"    \n\t"
     "  .align      3           \n\t"
     "  .long       1b - ., %l[l_yes] - .   \n\t"
     "  .quad       %c0 - .         \n\t"
     "  .popsection             \n\t"
     :  :  "i"(&amp;((char *)key)[branch]) :  : l_yes);

return false;
</code></pre>

<p>l_yes:</p>

<pre><code>return true;
</code></pre>

<p>}
```</p>

<p>There’s a lot going on here, so let’s take a look.  <code>1:</code> is a local label for
references within the asm block; it will get a temporary symbol name when
emitted.  <code>1:</code> points to a literal nop sled, but after the nop sled is the C
code following the <code>asm goto</code> statement.  That’s because the inline asm uses
the <code>.pushsection</code> directive to store the following data in an ELF section
that’s not <code>.text</code>.  We set the alignment of elements, then store two 32b
values and one 64b.  The <code>.long</code> directive has a comma that’s easy to miss, so
there’s two, and they’re compressed (<code>- .</code>) or made relative offsets of the
current location.  The first is the address of the beginning of the nop sled.
<code>1b</code> means local label named <code>1</code> searching <code>b</code>ackwards.  Finally, we store a
pointer to the <code>struct static_key</code> using pointer packing to add whether we’re
likely to take the branch or not.  The accessor functions will reconstruct the
two separate values correctly.</p>

<p>All this documentation is scattered throughout:</p>

<ul>
<li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/static-keys.txt">Documentation/static-keys.txt</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/x86/exception-tables.html">Documentation/x86/exception-tables.rst</a></li>
<li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/jump_label.h">include/linux/jump_label.h</a></li>
<li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/jump_label.c">kernel/jump_label.c</a></li>
<li>arch/{$ARCH}/include/asm/jump_label.h</li>
<li>arch/{$ARCH}/kernel/jump_label.c</li>
</ul>


<p>In fact, once you know this trick of using <code>.pushsection</code> in extended inline
assembly and storing addresses of data, then using linker defined symbols to
delineate section boundaries for quick searching and iteration, we start to see
this pattern occur all throughout the kernel (with or without <code>asm goto</code>).
<a href="https://lwn.net/Articles/531148/">This LWN article</a> discusses the trick and
the many custom ELF sections of a Linux image well.</p>

<p>Exception tables in the kernel in fact use very similar tricks of storing
addresses in custom ELF sections, <code>__ex_tables</code> and <code>.fixups</code> via inline
assembly.  The Linux kernel also sorts this data in the <code>__ex_table</code> section at
boot or even possibly post-link of the kernel image via BUILDTIME_TABLE_SORT,
so that at runtime the lookup of the exception handler can be done in log(N)
time via binary search! The .fixup also captures the address of the instruction
after the one that caused the exception, in order to possibly return control
flow to after successfully handling the exception.</p>

<p>&ldquo;Alternatives&rdquo; use this for patching in instructions that take advantage of ISA
extensions if we detect support for them at runtime.</p>

<p>A lot of kernel interfaces use function pointers that are written to once, then
either rarely or never modified.  It would be nice to replace these indirect
calls with direct calls.  In fact,
<a href="https://lwn.net/ml/linux-kernel/20200324135603.483964896@infradead.org/">patches have been proposed</a>
to lower the overhead of the Spectre &amp; Meltdown mitigations by doing just that.</p>

<p>Anyways, back to our story of debugging&hellip;</p>

<p>From here, I changed course and pursued another lead.  I had recently taught
LLVM’s inliner how to inline <code>asm goto</code> (or more so, when it was considered
safe to do so).  It seemed that LLVM’s inliner was not always respecting
<code>__attribute__((always_inline))</code> and could simply decide it wasn’t going to
perform an inline substitution.  (The inliner is a complex system; a large
analysis of multiple inputs distilled into a single yes/no signal, and all the
machinery necessary to perform such a code transformation).  The C standard (§
6.7.4
<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2479.pdf">ISO/IEC 9899:202x</a>)
says compilers are allowed to make their own decisions in regards to inline
substitution, so it’s generally more conservative to just say &ldquo;no&rdquo; when
presented with a highly complex or unusual case.</p>

<p>When the &ldquo;always inline&rdquo; function wasn’t inlined, it was no longer semantically
valid, since it was passing its parameters as input to the inline asm using the
&ldquo;i&rdquo; machine agnostic constraint for integral literals, amongst other
questionable uses of <code>__attribute__((always_inline))</code> within the kernel.</p>

<p>I was working around this (before I fixed LLVM) by changing the
<code>__attribute__((always_inline)</code> functions into macros (because the preprocessor
doesn’t have the ability to silently fail to transform as the inliner does).
But everything was working when I did that; the kernel booted just fine.  Had I
regressed something when inlining?  Was there a corner case I wasn’t thinking
of, which happens all the time in compiler development?  Was the compiler
haunted?  Was my code bad? Probably. (Porque no los dos?)</p>

<p>I start bisecting object files used to link the kernel image, mixing code that
is either called a static always inline vs a macro, and I narrow it down to 4
object files.</p>

<ul>
<li>arch/x86/kernel/tsc.o</li>
<li>kernel/time/hrtimer.o</li>
<li>kernel/time/timer.o</li>
<li>kernel/sched/clock.o</li>
</ul>


<p>Reading the time stamp counter! No wonder the kernel is failing so early;
initializing the clocks is one of the earlier tasks the kernel cares about.  A
preemptive multitasking operating system is obsessed with keeping track of
time; you spend up your time slice and you’re scheduled out.</p>

<p>But why would a <code>static inline __attribute__((always_inline))</code> function fail,
but succeed when the function was converted to a macro?</p>

<p>I mentioned this to my colleague Bill Wendling, who spotted a subtle
distinction in LLVM’s IR between the <code>static inline
__attribute__((always_inline))</code> version of the functions (and their call sites)
vs the macro.  Via
<a href="https://lists.llvm.org/pipermail/llvm-dev/2019-April/131518.html">an email to the list</a>:</p>

<blockquote><p>The code below is triggering some weird behavior that&rsquo;s different from how
gcc treats this inline asm. Clang keeps the original type of &ldquo;loc&rdquo; as &ldquo;bool&rdquo;,
which generates an &ldquo;i1 true&rdquo; after inlining. So far so good.  However, during
ISEL, the &ldquo;true&rdquo; is converted to a signed integer. So when it&rsquo;s evaluated,
the result is this:</p>

<pre><code>.quad (42+(-1))-.Ltmp0
</code></pre>

<p>(notice the &ldquo;-1&rdquo;). GCC emits a positive one instead:</p>

<pre><code>.quad 42 + 1 - .Ltmp0
</code></pre>

<p>I&rsquo;m not sure where the problem lies. Should the inline asm promote the &ldquo;i1&rdquo;
to &ldquo;i32&rdquo; during ISEL? Should it be promoted during inlining? Is there a
situation where we require the value to be &ldquo;i1&rdquo;?</p>

<p>-bw</p></blockquote>

<p>```c
typedef _Bool bool;</p>

<p>static inline
<strong>attribute</strong>((<strong>always_inline</strong>))
bool bar(bool loc) {</p>

<pre><code>    asm(".quad 42 + %c0 - .\n\t" : : "i" (loc));
    return 1;
</code></pre>

<p>}</p>

<p>int foo(void) {</p>

<pre><code>    return bar(1);
</code></pre>

<p>}
```
Krzysztof Parzyszek <a href="https://lists.llvm.org/pipermail/llvm-dev/2019-April/131526.html">responded the next day</a>.</p>

<blockquote><p>This is a bug in X86&rsquo;s ISel lowering: it does not take &ldquo;getBooleanContents&rdquo;
into account when extending the immediate value to 64 bits."</p></blockquote>

<p>Oh, shit!  LLVM’s IR has support for arbitrary width integers which is fine for
a high level language.  Because real machines typically don’t have support for
such integers of arbitrary width, the compiler typically has to find legal
widths for these integers (we say it &ldquo;legalizes the types&rdquo;) during lowering
from the high level abstract IR to low level concrete machine code.</p>

<p>To legalize a one bit integer into a 64 bit integer, we have to either zero
extend or sign extend it.  Generally, if we know the signedness of a number, we
sign extend signed integers to preserve the signedness of the uppermost bit, or
zero extend unsigned integers which don’t have a signedness bit to preserve.</p>

<p>But what happens when you have a boolean represented as a signed 1 bit number,
and you choose to sign extend it? <code>0x00</code> becomes <code>0x0000000000000000</code> which is
fine, but <code>0x01</code> becomes <code>0xFFFFFFFFFFFFFFFF</code>, ie. <code>-1</code>.  So when you expected
1, but instead got a -1, then you’re off by 2.  Preceding to use that in an
address calculation is going to result in some spooky bugs.</p>

<p>Recalling our inline <code>asm goto</code>, we we’re using this boolean to construct an
instance of a <code>struct jump_entry</code>’s <code>key</code> member, which was using pointer
packing to both refer to a global address and store whether the branch was
likely taken or not in the LSB.  When the value of <code>branch</code> was 0, we were
fine. But when <code>branch</code> was 1 and we sign extended it to -1, we kept the LSB as
1 but messed up the address of a global variable, resulting in the helper
function unpacking the pointer to a global <code>struct static_key</code> producing a bad
pointer.  Since the bottom two bits were dropped reconstituting the pointer, a
hypothetical value of 0x1001 would become 0xFFC (0x1001 &ndash; 2 &amp; ~3) which would
be wrong by 5 bytes. Thus we were interpreting garbage as a pointer, which led
to cascaded failure.</p>

<p>In this case, it looks like Bill spotted that during instruction selection
something unexpected was occuring, and Krystof narrowed it down from there.
<a href="https://reviews.llvm.org/D60208">Krystof had a fix available for x86</a>, which
<a href="https://reviews.llvm.org/D60224">Kees Cook later extended to all architectures</a>.
Since then,
<a href="https://reviews.llvm.org/D69876">Bill even extended LLVM’s implementation to allow for the mixed use of output constraints with <code>asm goto</code></a>,
something GCC doesn’t yet allow for, which is curious as Clang is now pushing a
GNU C extension further than GCC does.</p>

<p>(The true heroes of this story BTW are Alexander Ivchenko and Mikhail
Dvoretckii for
<a href="https://lists.llvm.org/pipermail/llvm-dev/2018-October/127239.html">providing the initial implementation</a>
of <code>asm goto</code> support in LLVM, and
<a href="https://reviews.llvm.org/D53765">Craig Topper</a> and
<a href="https://reviews.llvm.org/D56571">Jennifer Yu</a> (all Intel) for carrying the
implementation across the finish line.  Kudos to Chandler Carruth for <em>noting
the irony and uncanny coincidence</em> that it was both Intel that
<a href="https://lore.kernel.org/lkml/20180402095033.nfzcrmxvpm46dhbl@gmail.com/">regressed the x86 kernel build with Clang for over a year by requiring <code>asm goto</code> / CONFIG_JUMP_LABEL</a>,
and provided an implementation for it in Clang.)</p>

<p>0 based array indexing is the source of a common programmer error; off by one.
In this case, sign extending a boolean led to our <em>off by two</em>. (Or were we off
by one at being off by one?)</p>

<hr />

<p>I’m lucky to have virtual machines and debuggers, and the ability to introspect
my compiler, but I’m not sure if all of those were available back when Linux
was first written.  For fun, I asked Linus Torvalds what early debugging of the
Linux kernel was like (reprinted with permission):</p>

<p>Nick:</p>

<blockquote><p>What do you do for testing?  Quick boot tests in QEMU are my smoke tests, but
I&rsquo;m always interested in leveling up my workflow.</p></blockquote>

<p>Linus:</p>

<blockquote><p>I basically never do virtual machines. It happens &ndash; but mainly when chasing
kvm bugs. With half of the kernel being drivers, I find the whole &ldquo;run it in
emulation&rdquo; to be kind of pointless from an actual testing perspective.</p>

<p>Yeah, qemu is useful for quick smoke-tests, and for all the automated stuff
that gets run.</p>

<p>But the automation happens on the big farms, and I don&rsquo;t do the quick smoke
testing &ndash; if I get a pull requests from others, it had better be in good
enough shape that something like that is pointless, and when I do my own
development I prefer to think about the code and look at generated assembly
over trying to debug a mistake.</p>

<p>So if something doesn&rsquo;t work for me, that to me is a big red flag &ndash; I go and
really stare at the code and try to understand it even better.  I am not a
huge believer in debuggers, it&rsquo;s not how I&rsquo;ve ever coded.</p>

<p>I feel you get into a mindset where your code is determined by testing and
&ldquo;it works&rdquo;, rather than by actually thinking about it and knowing it and
believing it is correct.</p>

<p>But I probably just make excuses for &ldquo;this is how I started, because
emulation or debuggers just weren&rsquo;t an option originally, and now it&rsquo;s how I
work&rdquo;.</p></blockquote>

<p>Nick:</p>

<blockquote><p>One thing I am curious about is how the hell you ever debugged anything when
you were starting out developing Linux?  Was the first step get something
that could write out to the serial port?  (Do folks use serial debuggers on
x86? USB? We use them often on aarch64.  Not for attaching a debugger, more
so just for dmesg/printk).  Surely, it was some mix of &ldquo;just think really
hard about the code&rdquo; then at some point you had something a little nicer?
Graphics developers frequently have to contend with black screens and use
various colors like all-red/all-green/all-blue when debugging as a lone
signal of what&rsquo;s going wrong, which sucks, but is kind of funny.</p></blockquote>

<p>Linus:</p>

<blockquote><p>Hey, when you make a mistake early on in protected mode, the end result is
generally a triple fault &ndash; which results in an instant reboot.</p>

<p>So my early debugging &ndash; before I had console output and printk &ndash; was
literally &ldquo;let&rsquo;s put an endless loop here&rdquo;, and if the machine locked up you
were successful, and if it rebooted you knew you hadn&rsquo;t reached that point
because something went wrong earlier.</p>

<p>But it&rsquo;s not like doing VGA output was all <em>that</em> complicated, so &ldquo;write one
character to the upper corner of the screen&rdquo; came along pretty quickly. That
gives you a positive &ldquo;yeah, I <em>definitely</em> got this far&rdquo; marker, and not just
a &ldquo;hmm, maybe it locked up even before I got to my endless loop&rdquo;.</p>

<p>Fun days.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Let's Write Some x86-64]]></title>
    <link href="http://nickdesaulniers.github.io/blog/2014/04/18/lets-write-some-x86-64/"/>
    <updated>2014-04-18T16:16:00-07:00</updated>
    <id>http://nickdesaulniers.github.io/blog/2014/04/18/lets-write-some-x86-64</id>
    <content type="html"><![CDATA[<p><blockquote><p>&hellip;&ldquo;&lsquo;Our speech interposes itself between apprehension and truth like a dusty pane or warped mirror.  The tongue of Eden was like a flawless glass; a light of total understanding streamed through it.  Thus Babel was a second Fall.&rsquo; And Isaac the Blind, an early Kabbalist, said that, to quote Gershom Scholem&rsquo;s translation, &lsquo;The speech of men is connected with divine speech and all language whether heavenly or human derives from one source: the Divine Name.&rsquo; The practical kabbalists, the sorcerers, bore the title Ba'al Shem, meaning &lsquo;master of the divine name.&rsquo;&rdquo;</p></p><p><p>&ldquo;The machine language of the world,&rdquo; Hiro says.</p></p><p><p>&ldquo;Is this another analogy?&rdquo;</p></p><p><p>&ldquo;Computers speak machine language,&rdquo; Hiro says.  &ldquo;It&rsquo;s written in ones and zeroes &ndash; binary code.  At the lowest level, all computers are programmed with strings of ones and zeroes.  When you program in machine language, you are controlling the computer at its brainstem, the root of its existence.  It&rsquo;s the tongue of Eden.  But it&rsquo;s very difficult to work in machine language because you go crazy after a while, working at such a minute level.  So a whole Babel of computer languages has been created for programmers: FORTRAN, BASIC, COBOL, LISP, Pascal, C, PROLOG, FORTH.  You talk to the computer in one of these languages, and a piece of software called a compiler converts it into machine language.  But you never can tell exactly what the compiler is doing.  It doesn&rsquo;t always come out the way you want.  Like a dusty pane or warped mirror. A really advanced hacker comes to understand the true inner workings of the machine – he sees through the language he&rsquo;s working in and glimpses the secret functioning of the binary code – becomes a Ba'al Shem of sorts.&rdquo;</p><footer><strong>Hiro Protagonist and The Librarian</strong> <cite>Snow Crash by Neal Stephenson</cite></footer></blockquote></p>

<p>This a beautiful quote, one that I think truly captures the relationship between
higher level languages and the Instruction Set Architecture (ISA)&rsquo;s machine
code, though this is from the angle of controlling the machine with its
implementation specific quirks which can detract from what you&rsquo;re actually
trying to do.</p>

<p>This blog is meant for those who don&rsquo;t know x86-64 assembly, but maybe know a
little C, and are curious about code generation.  Or maybe if you&rsquo;ve ever tried
to hand write x86-64 assembly, and got stuck trying to understand the tooling or
seemingly random segfaults from what appears to be valid instructions.</p>

<p>I really enjoy writing code in CoffeeScript
and C, so I have a quick anecdote about CoffeeScript though you don&rsquo;t need to
know the language.  When writing CoffeeScript, I find myself frequently using a
<a href="https://github.com/kchmck/vim-coffee-script">vim plugin</a>
to view the emitted JavaScript.  I
<strong>know</strong> when CoffeeScript emits less than optimal JavaScript.  For example in
the code:</p>

<p><code>coffeescript
nick = -&gt; console.log x for x in [0..100]
</code></p>

<p>I know that CoffeeScript is going to push the results of the call to
<code>console.log</code> into an array
and return that, because of the implicit return of the final expression in a
function body, which in this case happens to be a for loop (array comprehension
being treated itself as an expression).  The emitted JavaScript looks like:</p>

<p>```javascript
var nick;</p>

<p>nick = function() {
  var x, <em>i, </em>results;
  <em>results = [];
  for (x = </em>i = 0; <em>i &lt;= 100; x = ++</em>i) {</p>

<pre><code>_results.push(console.log(x));
</code></pre>

<p>  }
  return _results;
};
```</p>

<p>By putting a seemingly meaningless undefined statement as the final statement in
the function body, we can significantly reduce what the function is doing and
decrease the number of allocations:</p>

<p><code>coffeescript
nick = -&gt;
  console.log x for x in [0..100]
  undefined
</code></p>

<p>emits:</p>

<p>```javascript
nick = function() {
  var x, <em>i;
  for (x = </em>i = 0; <em>i &lt;= 100; x = ++</em>i) {</p>

<pre><code>console.log(x);
</code></pre>

<p>  }
  return void 0;
};
```</p>

<p>That <code>return void 0</code> may seem odd, but functions in JavaScript without an
explicit return value return <code>undefined</code>, but since the <code>undefined</code> identifier
can be reassigned to, the expression <code>void 0</code>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void">evaluates to the value</a>
<code>undefined</code>.</p>

<p>You can see that making the CoffeeScript function body slightly longer and
adding a seemingly meaningless lone undefined statement at the end of the
function body, the emitted JavaScript does not allocate an array or waste time
pushing the results of <code>console.log</code>, which would be <code>undefined</code>, into that
array a hundred times.  This reminds me of how seemingly meaningless noop
instructions can keep a processor&rsquo;s pipeline full by preventing stalls, though
a pipeline stall doesn&rsquo;t change the correctness of a program, so it&rsquo;s an
imperfect analogy.</p>

<p>Now I&rsquo;m not saying that you should be thinking about these kinds of
optimizations when programming at such a high level, as they might be premature.
I shared with you this example because while writing C code, and reading
<a href="http://www.drdobbs.com/parallel/graphics-programming-black-book/184404919">Michael Abrash&rsquo;s Graphics Programming Black Book</a>,
<em>I wondered to myself if hardcore C
programmers also would know the equivalent assembly instructions that would be
emitted from their higher level C code</em> (before optimizing compilers even
existed).</p>

<p>In college, I was taught 68k and MIPS ISAs.
To understand x86-64 we need to be able to write and run it.
Unfortunately, I did not have the training to know how to do so.  My 68k code
was run on a MCU from a FreeScale IDE in Windows, so the process might as well
have been indistinguishable from magic to me.  I understood that you&rsquo;d start
with low level source, in (somewhat) human readable instructions that would be
converted to binary representing op codes.  The assembler would then translate
the assembly into non-executable object files that contained binary code that
had placeholders for sections of code defined in other object files.  The linker
would then be used to replace the placeholders with the now combined binary
code&rsquo;s relative positions and then converted into an executable.  But how do I
do this from my x86-64 machine itself?  The goto book I&rsquo;ve been recommended many
times is
<a href="http://www.wrox.com/WileyCDA/WroxTitle/productCd-0764579010.html">Professional Assembly Language by Richard Blum</a>,
but this book only
covers x86, not x86-64.  There&rsquo;s been some very big changes to the ABI between
x86 and x86-64.  You may be familiar with Application Programmer Interfaces
(<a href="http://en.wikipedia.org/wiki/Api">APIs</a>),
but what is an
<a href="http://en.wikipedia.org/wiki/Application_binary_interface">Application Binary Interface</a>?
I think of an ABI as how
two pieces of native code interact with one another, such as calling convention
(how arguments are passed to functions at the ISA level).</p>

<p>I&rsquo;m very lucky to have the privilege to work with a compiler engineer, Dan Gohman,
who has worked on a variety of compilers.  I was citing a
<a href="http://lists.cs.uiuc.edu/pipermail/llvmdev/2011-October/043719.html">particular email of Dan</a>&rsquo;s
for some time before he came to work with us, when I
would talk about how the naming of LLVM gives the imagery of a virtual machine,
though it&rsquo;s more so a compiler intermediate representation.  Dan is an amazing
and patient resource who has helped me learn more about the
subtleties of the x86-64 ABI.  Throughout this blog, I&rsquo;ll copy some responses to
questions I&rsquo;ve had answered by Dan.</p>

<p>Our first goal is to write an x86-64 program that does nothing, but that we can
build.  Assembly files typically have the .s file extension, so let&rsquo;s fire up
our text editor and get started.  I&rsquo;ll be doing my coding from OSX 10.8.5, but
most examples will work from Linux.  All of my symbol names, like _main, _exit,
and _printf, are prefixed with
underscores, as Darwin requires. Most Linux systems don&rsquo;t require this, so
Linux users should omit the leading underscores from all such names.  Unfortunately,
I cannot figure out how to link with ld in Linux, so I recommend trying to
understand what <code>gcc -v your_obj_file.o</code> is doing, and
<a href="http://www.lisha.ufsc.br/teaching/os/exercise/hello.html">this might help</a>.
Let me know in the comments if there&rsquo;s an easy way to use ld when linking your
object files from linux and I&rsquo;ll be happy to post an edit.</p>

<p>Let&rsquo;s start with this fragment and get it building, then I&rsquo;ll cover what it&rsquo;s
doing.</p>

<p><code>gas
.text
.globl _main
_main:
  subq $8, %rsp
  movq $0, %rdi
  call _exit
</code></p>

<p>Let&rsquo;s use OSX&rsquo;s built in assembler (as) and linker (ld).</p>

<p><code>
as nothing.s -o nothing.o
ld -lc -macosx_version_min 10.8.5 nothing.o -o nothing
</code></p>

<p>We should now be able to run <code>./nothing</code> without any segfaults.  Without
<code>-macosx_version_min 10.8.5</code> I get a warning and my executable segfaults.</p>

<p>Now let&rsquo;s create a basic generic Makefile to help us automate these steps.
Watch your step; archaic syntax ahead.</p>

<p>```make
SOURCES = $(wildcard *.s)
OBJECTS = $(SOURCES:.s=.o)
EXECUTABLES = $(OBJECTS:.o=)</p>

<h1>Generic rule</h1>

<h1>$&lt; is the first dependency name</h1>

<h1>$@ is the target filename</h1>

<p>%.o: %.s
  as $&lt; -o $@</p>

<p>default: $(OBJECTS)
  for exe in $(EXECUTABLES) ; do \</p>

<pre><code>ld -lc -macosx_version_min 10.8.5 $$exe.o -o $$exe ; \
</code></pre>

<p>  done</p>

<p>.PHONY: clean
clean:
  rm *.o
  for exe in $(EXECUTABLES) ; do \</p>

<pre><code>rm $$exe ; \
</code></pre>

<p>  done
```</p>

<p>By the time you read this, I&rsquo;ve already forgotten how half of that code works.
But, this will allow us to run <code>make</code> to assemble and link all of our .s files
individually, and <code>make clean</code> to remove our object and executable files.
Surely you can whip up a better build script?  Let me know in the comments
below.</p>

<p>So now let&rsquo;s go back to our assembly file and go over it line by line.  Again,
it looks like:</p>

<p><code>gas
.text
.globl _main
_main:
  subq $8, %rsp
  movq $0, %rdi
  call _exit
</code></p>

<p><code>.text</code> is the text section.  This section defines the instructions that the
processor will execute.  There can be other sections as well.  We&rsquo;ll see more
later, but the &ldquo;data&rdquo; section
typically has static variables that have been initialized with non null (and non
zero) values, where as &ldquo;bss&rdquo; will have static but non initialized values.  Also,
there will be a heap and a stack although you don&rsquo;t declare them as you would
for text or data.</p>

<p>Next up is the global directive.  The global directive tells the linker that
there will be a section named _main that it may call into, making the _main
section visible to other sections.  You may be
<a href="http://stackoverflow.com/a/5908708/1027966">wondering</a>
why directives and sections both begin with a dot.</p>

<p><blockquote><p>&lsquo;.&rsquo;&lsquo; isn&rsquo;t a valid identifier character in C, so way back when it became common to use &rsquo;.&lsquo;&rsquo; as a prefix in the assembler and linker in order to avoid clashing with C symbol names. This unfortunately was used for both section names and directives, because both can appear in contexts where a simple parser wouldn&rsquo;t be able to disambiguate otherwise.</p></p><p><p>I don&rsquo;t know why they used the same convention for directives and section names, but they did, and it&rsquo;s not practical to change it now.</p><footer><strong>Dan Gohman</strong></footer></blockquote></p>

<p>Ok now the subtraction instruction.  We&rsquo;ve got a bit to go over with just this
one line.  The first is the instruction itself.  The sub instruction has
numerous suffixes that specify how many bytes to operate on.  The typical
convention for numerous instructions is to have a suffix of b for 1 byte
(8 bits), w for a word (2 bytes, 16 bits), l for a long or
double word (4 bytes, 32 bits), and q for a quad word (8 bytes, 64 bits).
Leaving off the suffix, the assembler will try and guess based off of the
operands, which can lead to obscure bugs.  So subq operates on 64 bits.
Extending this we should be able to recognize that subb operates on 8 bits, subw
operates on 16 bits, subl operates on 32 bits, and subq operates on 64 bits.
What&rsquo;s important to understand is that instruction suffix is dictated by the
inputs and destination size.  See Figure 3-3 of the
<a href="http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2012/10/24592_APM_v11.pdf">AMD64 ABI</a>.</p>

<p>Ok now let&rsquo;s look at the full instruction <code>subq $8, %rsp</code>.  The current order of
the operands is known as the AT&amp;T syntax, where the destination is specified
last
(<a href="http://stackoverflow.com/q/972602/1027966">as opposed to the Intel syntax</a>,
where the destination follows the instruction name ex. <code>subq rsp, 8</code>).</p>

<p><blockquote><p>I&rsquo;m biased towards AT&amp;T-syntax because GCC, LLVM, and icc (at least on Unix-like platforms) all use it, so it&rsquo;s what I&rsquo;m used to by necessity. People familiar with assembly languages on other platforms sometimes find it feels backwards from what they&rsquo;re used to, but it is learnable.</p><footer><strong>Dan Gohman</strong></footer></blockquote></p>

<p>I&rsquo;m writing my examples in AT&amp;T syntax simply because when I compile my C code
from clang with the -S flag, or run my object files through gobjdump, I get AT&amp;T
syntax by default (though I&rsquo;m sure there are flags for either AT&amp;T or Intel
syntaxes).  Also, the ABI
docs are in AT&amp;T.  What are your thoughts on the two different syntaxes?  Let me
know in the comments below.</p>

<p>So when we say <code>subq $8, %rsp</code>, we&rsquo;re subtracting the immediate value of 8 from
the stack pointer (the register %rsp contains our stack pointer).  But
why are we doing this?  This is something that is left out from some of the
basic hello world assembly programs I&rsquo;ve seen.  This is the first ABI point I
want to make:</p>

<h2>x86-64 ABI point 1: function calls need the stack pointer to be aligned by a multiple of 16 bytes.</h2>

<p>By default, they are off by 8 on function entry.  See
Section 3.2.2 page 16 of the
<a href="https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf">ABI</a>.</p>

<p>Why is the stack pointer misaligned by 8 bytes on function entry?  I&rsquo;m going to
punt on the answer to that for a bit, but I promise I&rsquo;ll come back to it.  The
most important thing is that that call instruction later on will fail unless we
align our stack pointer, which started out misaligned.  If we comment it out
(pound signs, #, comment out the rest of the line) and make our executable,
we&rsquo;ll get a segfault.  You could even add 8 bytes to the stack pointer and our
basic example would work (we just need a multiple of 16 remember), but when we
learn later (I promise) about how the stack works in x86-64, we&rsquo;ll see we can
mess things up by adding rather than subtracting.</p>

<p>Next up we&rsquo;re moving the immediate value 0x0 into %rdi.  You may have heard that
arguments to functions are pushed on the stack in reverse order, but that&rsquo;s an
old x86 convention.  With the addition of 8 more general purpose registers, we
now pass up to the first 6 arguments in registers (then push the rest, if any,
on the stack in reverse order).  The convention (in OSX and Linux) is our second
ABI point:</p>

<h2>x86-64 ABI point 2: The calling conventions for function invocations require passing integer arguments in the following sequence of registers: %rdi, %rsi, %rdx, %rcx, %r8, %r9, then pushing the rest on the stack in reverse order.</h2>

<p>See <a href="https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf">section 3.2.3</a>
under &ldquo;Passing&rdquo;.  Warning:
<a href="http://msdn.microsoft.com/en-us/library/ms235286.aspx">Microsoft has a different calling convention</a>.
This is quite troubling to me, because I assumed that Instruction Set
Architectures were created so that the same code could run on two different
machines with the same microarchitecture, but because the ISA does not define
how arguments would be passed, this ambiguity is left up to the OS implementor
to decide.  Thus the same code may not run on two different machines with the
same microarchitecture if their operating systems are incompatible at the ABI
layer.</p>

<p><em>UPDATE</em>: Further, I just learned that <a href="http://nelhagedebugsshit.tumblr.com/post/84342207533/things-i-learned-writing-a-jit-in-go">Go, and C code compiled by 6c don’t use
the &ldquo;normal&rdquo; SysV ABI and calling convention, but have their own.</a></p>

<p>What our goal is is to call <code>exit(0);</code> where exit is defined in libc, which we
link against during the linking phase with with flag <code>-lc</code>.  This is another
punt on system calls.  So to invoke exit with the first integer argument of 0,
we first need to move the immediate value of 0x0 into %rdi.  Now if you run your
executable from your shell, then <code>echo $?</code>, you should see that the previous
command&rsquo;s exit code was 0.  Try changing the exit code to 42 and verify that it
works successfully.</p>

<p>Ok, well a program that does nothing is more boring than hello world.  Now that
we have our build setup out of the way, let&rsquo;s make a hello world program.  If
you&rsquo;re familiar with ASCII tables, we can use putchar from libc since we&rsquo;re
already linking to it.  Use <code>man putchar</code> to look at its signature and
<a href="http://www.asciitable.com/">this ASCII table</a> to move immediate values into a
certain register (remember the
calling convention, point #2) and make sure you setup the stack pointer before
any calls and exit after all other calls.</p>

<p>I&rsquo;ll leave that up to an exercise for the reader.  Let&rsquo;s use a string and
printf.</p>

<p>```gas
.data
_hello:
  .asciz &ldquo;hello world\n&rdquo;</p>

<p>.text
.globl <em>main
</em>main:
  subq $8, %rsp</p>

<p>  movb $0, %al
  leaq <em>hello(%rip), %rdi
  call </em>printf</p>

<p>  movq $0, %rdi
  call _exit
```</p>

<p>First up is our data section <code>.data</code>.  I previously mentioned the data section
contains global non null and non 0 variables.  You can see here that the string
itself becomes part of the binary by using the unix command <code>strings</code> and
passing your executable as the first argument.  Further, if you pass your
executable to hexdump you can even see the ASCII codes in hex:</p>

<p><code>
0001020 68 65 6c 6c 6f 20 77 6f 72 6c 64 0a 00 00 00 00
</code></p>

<p>Also, we can run our binary through objdump as well and see the string:</p>

<p><code>
gobjdump -j .data -s hello_world
...
Contents of section .data:
 2020 68656c6c 6f20776f 726c640a 00        hello world..
</code></p>

<p>Ok so now we&rsquo;re moving an immediate value of 0x0 to %al.  %al is 1 byte wide, so
we use the b suffix on the mov instruction.  The next important point of the ABI
has to do with functions that use a variable number of arguments (varargs), like
printf does:</p>

<h2>x86-64 ABI point 3: Variadic functions need to have the number of vector arguments specified in %al.</h2>

<p>This will make printf debugging hard without.  Also in
<a href="https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf">section 3.2.3 under passing</a>.</p>

<p>If you don&rsquo;t know what vector arguments are, no worries!  I&rsquo;m not going to cover
them.  Just know that without this, the contents of %al may work in a basic
example, where we haven&rsquo;t touched %al, %ax, %eax, or %rax yet, but we shouldn&rsquo;t
bank on it being 0x0.  In fact we shouldn&rsquo;t bank on most registers being
preserved after a function call.  Now&rsquo;s a good time to talk about volatility:</p>

<h2>x86-64 ABI point 4: Most registers are not preserved across function calls.</h2>

<p>Only %rbx, %rsp, %rbp, and %r12-%r15 (and some others) are.  These are called
&ldquo;call saved&rdquo; or &ldquo;non volatile&rdquo; registers.  The rest should be considered &ldquo;call
clobbered&rdquo; or &ldquo;volatile.&rdquo;  That means every time we invoke a call like printf,
we need to reset %al, since it is the lower 8 bits of %rax which is the 1st
return register, so it is always clobbered.</p>

<p>The next instruction loads the effective address of the string relative to the
current instruction pointer into %rdi, the first argument for printf.
<a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/Assembler/040-Assembler_Directives/asm_directives.html">The .asciz directive</a> appends the null byte for us, since C strings are null
terminated.</p>

<p>With this knowledge, can you modify hello world to print &ldquo;hello world 42&rdquo;,
without putting 42 into the string in the data section?  Hint: you&rsquo;ll need a
placeholder in your string and need to know the x86-64 calling convention to
pass an additional argument to printf.</p>

<p>Finally, let&rsquo;s talk about the stack.  When we create automatic variables in C,
they are created in the segment called the stack.  On x86-64 the stack starts
at some arbitrary address (virtual memory backed by physical memory) and &ldquo;grows&rdquo;
downwards.  That is why we subtracted 8 bytes, rather than add 8 bytes to the
stack for alignment earlier.
<a href="http://eli.thegreenplace.net/2011/02/04/where-the-top-of-the-stack-is-on-x86/">The metaphor of a stack of plates is kinda upside-down</a>
as additional plates (variables) are going underneath the current
bottom plate if you can imagine, in this case.  The stack grows towards the
heap, and it is possible for them to collide if you don&rsquo;t ask the OS to expand
your data segment (sbrk).</p>

<p><img class="center" src="/images/stack.png"> <a href="http://mcfunley.com/the-debugger-extension-part-6-scanning-threads">credit</a></p>

<p>Let&rsquo;s say we want to call something like memset, which from <code>man memset</code> we can
see takes an address, a value to fill, and a number of bytes to fill.  The
equivalent of say this C code:</p>

<p>```c</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;inttypes.h></h1>

<p>int main () {
  int8_t array [16];
  memset(&amp;array, 42, 16);
  int8_t<em> ptr = array;
  printf(&ldquo;Current byte: %&rdquo; PRId8 &ldquo;\n&rdquo;, </em>ptr);
  ++(<em>ptr);
  printf(&ldquo;Current byte: %&rdquo; PRId8 &ldquo;\n&rdquo;, </em>ptr);
  ++ptr;
  printf(&ldquo;Current byte: %&rdquo; PRId8 &ldquo;\n&rdquo;, *ptr);
}
```</p>

<p>Well, that might look like:</p>

<p>```gas
.data
_answer:
  .asciz &ldquo;Current byte: %d\n&rdquo;</p>

<p>.text
.globl <em>main
</em>main:
  subq $8, %rsp</p>

<p>  subq $16, %rsp # allocate 16B
  leaq (%rsp), %rdi # first arg, &amp;array
  movq $42, %rsi # second arg, 42
  movq $16, %rdx, # third arg, 16B
  call _memset</p>

<p>  leaq <em>answer(%rip), %rdi
  movq $0, %rsi
  movb (%rsp), %sil # these two are equavlent to movzql (%rsp), %esi
  movb $0, %al
  call </em>printf</p>

<p>  incq (%rsp)</p>

<p>  leaq <em>answer(%rip), %rdi
  movq $0, %rsi
  movb (%rsp), %sil
  movb $0, %al
  call </em>printf</p>

<p>  leaq <em>answer(%rip), %rdi
  movq $0, %rsi
  movb 1(%rsp), %sil
  movb $0, %al
  call </em>printf</p>

<p>  addq $16, %rsp # clean up stack</p>

<p>  movq $0, %rdi
  call _exit
```</p>

<p>This isn&rsquo;t a perfect example because I&rsquo;m not allocating space for the ptr on the
stack.  Instead, I&rsquo;m using the %rsp register to keep track of the address I&rsquo;m
working with.</p>

<p>What we&rsquo;re doing is allocating 16B on the stack.  Remember we need to keep %rsp
aligned on 16B boundaries, making it a multiple of 16B.  If we needed a non 16B
multiple, we could allocate more than needed on the stack, and then do some
arithmetic later when access our automatic variables.</p>

<p>For memset, we need to pass the address of our first argument.  In x86-64, the
stack grows downwards, but our variables &ldquo;point&rdquo; upwards, so %rsp and the higher
16B is the memory addresses of our array, with %rsp currently pointing to the
front.  The rest you should recognize by now as part of the calling convention.</p>

<p>In the next grouping of instructions, we want to verify that memset set every
byte to 42 (0x2A).  So what we&rsquo;ll do is copy the first byte from our array,
currently pointed to by %rsp, to the lower 8b of %rsi which is named %sil.  It&rsquo;s
important to zero out the 64b contents of %rsi first, since it may have been
clobbered by our previous call to memset.</p>

<p>Then we dereference and increment the value pointed to by our array pointer,
<code>++(*ptr)</code> or <code>++array[0]</code>.  Now <code>array[0]</code> is <code>43</code>, not <code>42</code>.</p>

<p>In the next grouping of instructions, we print the second byte of our array,
<code>array[1]</code>, and get <code>42</code> from memset.  Now we could try to increment the stack
pointer itself by one, but then the call to printf will fail, so instead when we
load the value of <code>array[1]</code>, we do some pointer arithmetic
<code>movb 1(%rsp), %sil</code>.
This is relative addressing, though you&rsquo;ve already seen this with loading the
strings.  You might wonder why I&rsquo;m not loading the byte in the other
&ldquo;direction,&rdquo; say <code>movb -1(%rsp), %sil</code>.  Well, that goes back to my point that
while the stack pointer moves down as we allocate automatic variables, their
address and memory they take up &ldquo;points up.&rdquo;</p>

<p>Finally, we clean up our automatic variable&rsquo;s allocated space on the stack.
Note that we do not zero out that memory.  A preceding function call might
overwrite that data on the stack, but until it does or unless we explicitly zero
it out, a buffer overrun could accidentally read that data a la Heartbleed.</p>

<p>Now I did promise I would talk about why the stack pointer is misaligned by 8
bytes on function entry.  That is because unoptimized functions typically have a
function prolog and epilog.  Typically, besides creating
room on the stack for automatic variables at the beginning of a function, we
typically want to save the frame AKA base pointer, %rbp, on the stack.  Since
%rbp is 64b or 8B and the push instruction will decrement the stack pointer by
8b, this will align the misaligned stack to a 16B multiple.  So
in function bodies, you&rsquo;ll typically see:</p>

<p><code>gas
my_func:
  push %rbp
  movq %rsp, %rbp
  # your code here...
  popq %rbp
  ret
</code></p>

<p><a href="http://www.yosefk.com/blog/getting-the-call-stack-without-a-frame-pointer.html">This great article</a>
explains that you may want to profile your running
application, or look at the call stack in a debugger, and by having a linked
list of stack frames of the function that invoked yours and it&rsquo;s caller and so
on in a dedicated register makes it trivial to know the call stack at any given
point in runtime.  Since we&rsquo;re always pushing %rbp immediately thereby saving it
on the stack and putting our stack pointer (%rsp) in the base pointer (%rbp)
(later restoring it, %rbp is call saved), we can
keep popping %rbp then moving our stack pointer to that value
to see that quux was called by bar was called by foo
(<code>foo(bar(quux()));</code>).  Now you saw that I was able to write code that clearly
worked without the three additonal instructions in the prolog and epilog, and
indeed that&rsquo;s what happens with <em>optimized</em> code emitted from your compiler.
And since GDB uses something called DWARF (adds symbols to your objects)
anyways, it isn&rsquo;t a huge issue to remove the prolog and epilog.</p>

<p>So, I think I&rsquo;ve shown you enough to get started hand writing assembly.  To
learn more, you should write the higher level C code for what you&rsquo;re trying to
do and then
<a href="http://www.expobrain.net/2013/06/16/disassembly-c-code-for-fun-part-1/">study the emitted assembly</a>
by compiling with the -S flag.  With
clang, you&rsquo;ll probably see a bunch of stack check guards for each frame, but
those just prevent stack buffer overflows.  Try compiling simple conditionals
(jump forwards), then simple loops (jump backwards) without optimizations.
Jumping to sections and calling your own functions should be pretty
easy to figure out.  Hint: don&rsquo;t duplicate section names, but the assembler will
catch this and warn you pretty explicitly.</p>

<p>Don&rsquo;t let people discourage from learning assembly because &ldquo;compilers will
always beat you.&rdquo;  &ldquo;Just use LLVM or libjit or whatever for codegen.&rdquo;  Well,
existing solutions aren&rsquo;t perfect solutions in every scenario.  Someday you
might be tasked with doing codegen because LLVM is not optimal under certain
constraints.  You&rsquo;ll never know if
you can beat them unless you try; those most comfortable are those most
vulnerable.
I&rsquo;m afraid that if enough people are turned away from
learning the lower levels of programming because the higher level is
unquestionably
better, then assembly will ultimately be forgotten and the computer becomes a
black box again.  This is something that troubles me and that I see occurring
around me frequently; a lot of devs new to web
development conflate jquery with JavaScript, and Three.js with WebGL.  If you&rsquo;re
around the Bay Area, I&rsquo;ll be giving a talk at
<a href="http://html5devconf.com/">HTML5DevConf</a>
on May 22 demystifying Raw WebGL.  You should come and check it out.</p>

<p>In summary, remember:</p>

<ul>
<li>The stack pointer needs to be aligned by 16B multiples when calling another function.</li>
<li>Calling convention dictates passing arguments in %rdi, %rsi, %rdx, %rcx, %r8, %r9, then stack.</li>
<li>%al needs the number of vector arguments for variadic functions.</li>
<li>Know which registers are call saved (%rbx, %rsp, %rbp, and %r12-%r15 (and some others)) and call clobbered.</li>
</ul>


<p>Closing thoughts by Dan:</p>

<p><blockquote><p>To me, machine code doesn&rsquo;t feel analogous to this concept of the divine name. I certainly wouldn&rsquo;t describe it as &ldquo;like a flawless glass; a light of total understanding streamed through it&rdquo;. Even if you strip away all the accidental complexity, machine code is still permeated by mundane implementation-oriented concerns. Also, the abstractions which we use to organize and &ldquo;understand&rdquo; the program are gone; information is lost.</p></p><p><p>My imagination of a divine language looks a lot more like an idealized and cleaned-up LISP. It&rsquo;d be capable of representing all known means of abstraction and combination (in the SICP sense), it might be thought of as a kind of super-language of which all of our real-world languages are just messy subsets.</p><footer><strong>Dan Gohman</strong></footer></blockquote></p>
]]></content>
  </entry>
  
</feed>
