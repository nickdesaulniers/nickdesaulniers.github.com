<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=/css/fonts.css rel=stylesheet type=text/css><title>Designated Initialization With Compound Literals in C</title><link rel=stylesheet href=/css/hugo-octopress.css><link rel=stylesheet href=https://nickdesaulniers.github.io/css/custom.css><link rel=stylesheet href=/css/fork-awesome.min.css><link href=https://nickdesaulniers.github.io/favicon.ico rel=icon><meta name=description content><meta name=keywords content><meta name=author content="Nick Desaulniers"><meta name=generator content="Hugo 0.109.0"></head><body><header role=banner><hgroup><h1><a href=https://nickdesaulniers.github.io/>Nick Desaulniers</a></h1><h2>The enemy's gate is down</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value"><option value>Navigate…</option><option value=https://nickdesaulniers.github.io/about/>» About</option><option value=https://nickdesaulniers.github.io/blog/archives/>» Archives</option><option value=https://nickdesaulniers.github.io/>» Blog</option><option value=https://nickdesaulniers.github.io/publications/>» Publications</option><option value=https://nickdesaulniers.github.io/talks/>» Talks</option></select></fieldset><ul class=main-navigation><li><a href=https://nickdesaulniers.github.io/about/ title=About rel="noopener noreferrer">About</a></li><li><a href=https://nickdesaulniers.github.io/blog/archives/ title=Archives rel="noopener noreferrer">Archives</a></li><li><a href=https://nickdesaulniers.github.io/ title=Blog>Blog</a></li><li><a href=https://nickdesaulniers.github.io/publications/ title=Publications rel="noopener noreferrer">Publications</a></li><li><a href=https://nickdesaulniers.github.io/talks/ title=Talks rel="noopener noreferrer">Talks</a></li></ul><ul class=subscription><a href=https://nickdesaulniers.github.io/index.xml target=_blank type=application/rss+xml title=RSS rel="noopener noreferrer"><i class="fa fa-rss-square fa-lg"></i></a></ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer"><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:https://nickdesaulniers.github.io/></fieldset></form></nav><div id=main><div id=content><div><article class=hentry role=article><header><p class=meta>Jul 25, 2013
- 5 minute read
- <a href=https://nickdesaulniers.github.io/blog/2013/07/25/designated-initialization-with-pointers-in-c/#disqus_thread>Comments</a>
- <a class=label href=https://nickdesaulniers.github.io/categories/c/>C </a><a class=label href=https://nickdesaulniers.github.io/categories/syntax/>syntax</a></p><h1 class=entry-title>Designated Initialization With Compound Literals in C</h1></header><div class=entry-content><p>Just a quick post on something I just discovered and found neat (I always find
obscure C syntax interesting). I was trying to figure out how to use a C
designated initializer, where a member was a pointer to another designated
initializer. At this point, you need a compound literal. Just a quick
background on C initialization:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#586e75>// verbosely create an array with a known size
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#dc322f>int</span> arr [<span style=color:#2aa198>3</span>];
</span></span><span style=display:flex><span>arr[<span style=color:#2aa198>0</span>] <span style=color:#719e07>=</span> <span style=color:#2aa198>1</span>;
</span></span><span style=display:flex><span>arr[<span style=color:#2aa198>1</span>] <span style=color:#719e07>=</span> <span style=color:#2aa198>2</span>;
</span></span><span style=display:flex><span>arr[<span style=color:#2aa198>2</span>] <span style=color:#719e07>=</span> <span style=color:#2aa198>3</span>;
</span></span><span style=display:flex><span><span style=color:#586e75>// =&gt; [1, 2, 3]
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span><span style=color:#586e75>// concisely create an array with a known size
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#dc322f>int</span> arr [<span style=color:#2aa198>3</span>] <span style=color:#719e07>=</span> { <span style=color:#2aa198>1</span>, <span style=color:#2aa198>2</span>, <span style=color:#2aa198>3</span> }; <span style=color:#586e75>// =&gt; [1, 2, 3]
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span><span style=color:#586e75>// creates an array with unspecified values initialized to 0
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#dc322f>int</span> arr [<span style=color:#2aa198>4</span>] <span style=color:#719e07>=</span> { <span style=color:#2aa198>1</span>, <span style=color:#2aa198>2</span>, <span style=color:#2aa198>3</span> }; <span style=color:#586e75>// =&gt; [1, 2, 3, 0]
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span><span style=color:#586e75>// truncates declaration
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#dc322f>int</span> arr [<span style=color:#2aa198>1</span>] <span style=color:#719e07>=</span> { <span style=color:#2aa198>1</span>, <span style=color:#2aa198>2</span>, <span style=color:#2aa198>3</span> }; <span style=color:#586e75>// =&gt; [1]
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span><span style=color:#586e75>// based on number of initializers
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#dc322f>int</span> arr [] <span style=color:#719e07>=</span> { <span style=color:#2aa198>1</span>, <span style=color:#2aa198>2</span>, <span style=color:#2aa198>3</span> }; <span style=color:#586e75>// =&gt; [1, 2, 3]
</span></span></span></code></pre></div><p>Let&rsquo;s look at how we might have initialized a struct in C89. In C89, you are
required to declare local variables at the top of a block. A previous
initialization of a point struct might have looked like:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>struct</span> point {
</span></span><span style=display:flex><span>  <span style=color:#dc322f>int</span> x, y;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#719e07>struct</span> point a;
</span></span><span style=display:flex><span>  a.x <span style=color:#719e07>=</span> <span style=color:#2aa198>2</span>;
</span></span><span style=display:flex><span>  a.y <span style=color:#719e07>=</span> <span style=color:#2aa198>3</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Just as we can define array literals in C using the initializer list syntax, we
can use the same concise syntax for initializing structs!</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#586e75>// point a is located at (2, 3)
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#719e07>struct</span> point a <span style=color:#719e07>=</span> { <span style=color:#2aa198>2</span>, <span style=color:#2aa198>3</span> };
</span></span></code></pre></div><p>Well, this can be bad. Where would point a be located if say a fellow team
mate came along and modified the definition of the point struct to:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>struct</span> point {
</span></span><span style=display:flex><span>  <span style=color:#dc322f>int</span> y, x; <span style=color:#586e75>// used to be `int x, y;`
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>};
</span></span></code></pre></div><p>Suddenly point a points to (3, 2), not (2, 3). It&rsquo;s better if you use
designated initializers to declare the values for members of your struct. It&rsquo;s
up to the compiler to decide on the order of initialization, but it wont mess
up where the data is intended to go.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#586e75>// point b is located at (2, 3)
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#719e07>struct</span> point b <span style=color:#719e07>=</span> { .y <span style=color:#719e07>=</span> <span style=color:#2aa198>3</span>, .x <span style=color:#719e07>=</span> <span style=color:#2aa198>2</span> };
</span></span></code></pre></div><p>So now we have designated initializers, cool. What about if we want to use the
same syntax to reassign point b?</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>b <span style=color:#719e07>=</span> { .x <span style=color:#719e07>=</span> <span style=color:#2aa198>5</span>, .y <span style=color:#719e07>=</span> <span style=color:#2aa198>6</span> };
</span></span><span style=display:flex><span><span style=color:#586e75>//    ^
</span></span></span><span style=display:flex><span><span style=color:#586e75>// error: expected expression
</span></span></span></code></pre></div><p>While you are being explicit about the shape of the struct that you are trying
to assign to b, the compiler cannot figure out that you&rsquo;re trying to assign a
point struct to another point struct. A C cast would probably help here and
that&rsquo;s what the concept of compound literals are.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>b <span style=color:#719e07>=</span> (<span style=color:#719e07>struct</span> point) { .x <span style=color:#719e07>=</span> <span style=color:#2aa198>5</span>, .y <span style=color:#719e07>=</span> <span style=color:#2aa198>6</span> }; <span style=color:#586e75>// works!
</span></span></span></code></pre></div><p>Notice: I just combined a compound literal with a designated initializer. A
compound literal on its own would look like:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>b <span style=color:#719e07>=</span> (<span style=color:#719e07>struct</span> point) { <span style=color:#2aa198>5</span>, <span style=color:#2aa198>6</span> }; <span style=color:#586e75>// works!
</span></span></span></code></pre></div><p>To recap we can define points like so:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>struct</span> point a;
</span></span><span style=display:flex><span>a.x <span style=color:#719e07>=</span> <span style=color:#2aa198>1</span>;
</span></span><span style=display:flex><span>a.y <span style=color:#719e07>=</span> <span style=color:#2aa198>2</span>; <span style=color:#586e75>// C89 (too verbose)
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#719e07>struct</span> point b <span style=color:#719e07>=</span> { <span style=color:#2aa198>3</span>, <span style=color:#2aa198>4</span> }; <span style=color:#586e75>// initializer list (struct member order specific)
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#719e07>struct</span> point c <span style=color:#719e07>=</span> { .x <span style=color:#719e07>=</span> <span style=color:#2aa198>5</span>, .y <span style=color:#719e07>=</span> <span style=color:#2aa198>6</span> }; <span style=color:#586e75>// designated initializer (non struct member order specific)
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#719e07>struct</span> point d <span style=color:#719e07>=</span> (<span style=color:#719e07>struct</span> point) { .x <span style=color:#719e07>=</span> <span style=color:#2aa198>7</span>, .y <span style=color:#719e07>=</span> <span style=color:#2aa198>8</span> }; <span style=color:#586e75>// compound literal (cast + designated initialization)
</span></span></span></code></pre></div><p>My favorite part of compound literals is that you can define values inline of
an argument list. Say you have a function prototype like:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>distance</span> (<span style=color:#719e07>struct</span> point, <span style=color:#719e07>struct</span> point);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>// instead of calling it like this
</span></span></span><span style=display:flex><span><span style=color:#586e75>// (creating temp objects just to pass in)
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#719e07>struct</span> point a <span style=color:#719e07>=</span> { .x <span style=color:#719e07>=</span> <span style=color:#2aa198>1</span>, .y <span style=color:#719e07>=</span> <span style=color:#2aa198>2</span> };
</span></span><span style=display:flex><span><span style=color:#719e07>struct</span> point b <span style=color:#719e07>=</span> { .x <span style=color:#719e07>=</span> <span style=color:#2aa198>5</span>, .y <span style=color:#719e07>=</span> <span style=color:#2aa198>6</span> };
</span></span><span style=display:flex><span><span style=color:#268bd2>distance</span>(a, b);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>// we can use compound literals
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>distance</span>((<span style=color:#719e07>struct</span> point) { .x <span style=color:#719e07>=</span> <span style=color:#2aa198>1</span>, .y <span style=color:#719e07>=</span> <span style=color:#2aa198>2</span> }, (<span style=color:#719e07>struct</span> point) { .x <span style=color:#719e07>=</span> <span style=color:#2aa198>5</span>, .y <span style=color:#719e07>=</span> <span style=color:#2aa198>6</span> });
</span></span></code></pre></div><p>So compound literals help with reassignment of structs, and not storing
temporary variables just to pass as function arguments. What happens though
when one of your members is a pointer? C strings are easy because they already
have a literal value:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>struct</span> node {
</span></span><span style=display:flex><span>  <span style=color:#dc322f>char</span> <span style=color:#719e07>*</span>value;
</span></span><span style=display:flex><span>  <span style=color:#719e07>struct</span> node <span style=color:#719e07>*</span>next;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>// just using designated initialization
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#719e07>struct</span> node a <span style=color:#719e07>=</span> {
</span></span><span style=display:flex><span>  .value <span style=color:#719e07>=</span> “hello world”,
</span></span><span style=display:flex><span>  .next <span style=color:#719e07>=</span> <span style=color:#b58900>NULL</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>But what happens if we want to initialize node.next? We could do:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>struct</span> node b <span style=color:#719e07>=</span> {
</span></span><span style=display:flex><span>  .value <span style=color:#719e07>=</span> “foo”,
</span></span><span style=display:flex><span>  .next <span style=color:#719e07>=</span> <span style=color:#b58900>NULL</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>a.next <span style=color:#719e07>=</span> <span style=color:#719e07>&amp;</span>b;
</span></span></code></pre></div><p>Again, we have to define b before assigning it to a.next. That&rsquo;s worthwhile if
you need to reference b later in that scope, but sometimes you don&rsquo;t (just like
how compound literals can help with function arguments)! But that&rsquo;s where I
was stumped. How do you nest designated initializers when the a member is a
pointer to another designated initializer? A first naïve attempt was:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>struct</span> node c <span style=color:#719e07>=</span> {
</span></span><span style=display:flex><span>  .value <span style=color:#719e07>=</span> “bar”,
</span></span><span style=display:flex><span>  .next <span style=color:#719e07>=</span> {
</span></span><span style=display:flex><span>    .value <span style=color:#719e07>=</span> “baz”,
</span></span><span style=display:flex><span><span style=color:#586e75>//  ^
</span></span></span><span style=display:flex><span><span style=color:#586e75>// error: designator in initializer for scalar type &#39;struct node *&#39;
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    .next <span style=color:#719e07>=</span> <span style=color:#b58900>NULL</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>WTF? Well, if you go back to the example with nodes a and b, we don&rsquo;t assign
the value of b to a.next, we assign it a pointer to b. So how can we use
designated initializers to define, say, the first two nodes of a linked list?
Compound literals. Remember, a compound literal is essentially a designated
initialization + cast.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>struct</span> node d <span style=color:#719e07>=</span> {
</span></span><span style=display:flex><span>  .value <span style=color:#719e07>=</span> “qux”,
</span></span><span style=display:flex><span>  .next <span style=color:#719e07>=</span> <span style=color:#719e07>&amp;</span>((<span style=color:#719e07>struct</span> node) {
</span></span><span style=display:flex><span>    .value <span style=color:#719e07>=</span> “fred”,
</span></span><span style=display:flex><span>    .next <span style=color:#719e07>=</span> <span style=color:#b58900>NULL</span>
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>And that works, but why? d.next is assigned an address of a
compound literal. Granted, you probably don&rsquo;t want to be declaring your entire
linked list like this, as nesting gets out of control fast. I really like this
style because it reminds me of JavaScript&rsquo;s syntax for declaring object
literals. It would look nicer if all of your nested structs were values and
not references though; then you could just use designated initializers and
wouldn&rsquo;t need compound literals or address of operators.</p><p>What&rsquo;s your favorite or most interesting part of C syntax?</p><p>Acknowledgements:</p><ul><li><a href=http://louisstowasser.com/ target=_blank rel=noopener>Louis Stowasser</a></li><li><a href=http://fredericiana.com/ target=_blank rel=noopener>Frederic Wenzel</a></li><li><a href=http://shop.oreilly.com/product/0636920025108.do target=_blank rel=noopener>21st Century C</a></li></ul></div><footer><p class=meta><span class="byline author vcard">Posted by <span class=fn>Nick Desaulniers</span></span>
<time>Jul 25, 2013</time></span></p><p class=meta><a class="basic-alignment left" href=https://nickdesaulniers.github.io/blog/2013/07/03/why-ill-be-marching-this-4th/ title="Why I'll Be Marching This 4th">Why I'll Be Marching This 4th</a>
<a class="basic-alignment right" href=https://nickdesaulniers.github.io/blog/2013/08/28/making-great-node-dot-js-modules-with-coffeescript/ title="Making Great Node.js Modules With Coffeescript">Making Great Node.js Modules With Coffeescript</a></p><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//wangstabill.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></div><aside class="sidebar thirds"><section class="first odd"><p></p></section><ul class=sidebar-nav><li class=sidebar-nav-item><a target=_blank rel="noopener noreferrer" href=https://github.com/nickdesaulniers title=https://github.com/nickdesaulniers><i class="fa fa-github fa-3x"></i></a>
<a target=_blank rel="me noopener noreferrer" href=https://fosstodon.org/@llvm title=https://fosstodon.org/@llvm><i class="fa fa-mastodon fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href=https://www.linkedin.com/in/nick-desaulniers-75520334 title=https://www.linkedin.com/in/nick-desaulniers-75520334><i class="fa fa-linkedin fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href=https://www.youtube.com/channel/UC68vgKSuS1Xjg9wpdvShfSQ title=https://www.youtube.com/channel/UC68vgKSuS1Xjg9wpdvShfSQ><i class="fa fa-youtube fa-3x"></i></a></li></ul><section class=even><h1>Recent Posts</h1><ul id=recent_posts><li class=post><a href=/blog/2023/02/01/forking-is-not-free-the-hidden-costs/>Forking is not free; the hidden costs</a></li><li class=post><a href=/blog/2023/01/27/critical-edge-splitting/>Critical Edge Splitting</a></li><li class=post><a href=/blog/2023/01/20/debugging-wframe-larger-than/>Debugging -Wframe-larger-than=</a></li><li class=post><a href=/blog/2020/04/06/off-by-two/>Off by Two</a></li></ul></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2023 Nick Desaulniers - <a href=https://nickdesaulniers.github.io/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.</p></footer><script>var _gaq=[["_setAccount","UA-36993986-1"],["_trackPageview"]];(function(e,t){var n=e.createElement(t),s=e.getElementsByTagName(t)[0];n.src=("https:"==location.protocol?"//ssl":"//www")+".google-analytics.com/ga.js",s.parentNode.insertBefore(n,s)})(document,"script")</script></body></html>